<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>terminal.flow.bid</title>
<style>
  :root {
    --bg: #000;
    --fg: #fff;
    --muted: #888;
    --dim: #555;
    --border: #333;
    --green: #44ff44;
    --red: #ff4444;
    --yellow: #ffaa44;
    --cyan: #44ddff;
    --bar-bg: #222;
    --bar-fill: #fff;
  }
  [data-theme="light"] {
    --bg: #fff;
    --fg: #000;
    --muted: #666;
    --dim: #aaa;
    --border: #ccc;
    --green: #007700;
    --red: #cc0000;
    --yellow: #aa7700;
    --cyan: #0077aa;
    --bar-bg: #e0e0e0;
    --bar-fill: #000;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--bg);
    color: var(--fg);
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
    font-size: 13px;
    line-height: 1.5;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* Top bar */
  .topbar {
    padding: 8px 16px;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    font-size: 12px;
    color: var(--muted);
  }
  .topbar .title { color: var(--fg); font-size: 14px; }
  .topbar .wallet span { color: var(--fg); }
  .topbar button {
    background: none;
    border: none;
    color: var(--muted);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    padding: 0 4px;
  }
  .topbar button:hover { color: var(--fg); }

  /* Tab bar */
  .tabbar {
    display: flex;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    padding: 0 16px;
    font-size: 12px;
  }
  .tab {
    padding: 6px 16px;
    cursor: pointer;
    color: var(--muted);
    border-bottom: 2px solid transparent;
    user-select: none;
  }
  .tab:hover { color: var(--fg); }
  .tab.active {
    color: var(--fg);
    border-bottom-color: var(--fg);
  }

  /* Tab content */
  .tab-content {
    display: none;
    flex-direction: column;
    flex: 1;
    overflow: hidden;
    min-height: 0;
  }
  .tab-content.active {
    display: flex;
  }

  /* Monitor panel (per-tab) */
  .tab-monitor {
    flex-shrink: 0;
    display: none;
    border-bottom: 1px solid var(--border);
    max-height: 50vh;
    overflow-y: auto;
  }
  .tab-monitor.active { display: block; }
  .tab-monitor .monitor-expanded + .monitor-expanded,
  .tab-monitor .monitor-expanded + .monitor-collapsed,
  .tab-monitor .monitor-collapsed + .monitor-expanded,
  .tab-monitor .monitor-collapsed + .monitor-collapsed {
    border-top: 1px solid var(--border);
  }

  /* Output (per-tab) */
  .tab-output {
    flex: 1;
    overflow-y: auto;
    padding: 12px 16px;
    white-space: pre-wrap;
    word-break: break-all;
    font-size: 13px;
  }
  .tab-output .line { margin-bottom: 2px; }
  .tab-output .cmd { color: var(--cyan); }
  .tab-output .ok { color: var(--green); }
  .tab-output .err { color: var(--red); }
  .tab-output .warn { color: var(--yellow); }
  .tab-output .dim { color: var(--muted); }

  /* Collapsed: single row */
  .monitor-collapsed {
    padding: 6px 16px;
    display: flex;
    align-items: center;
    gap: 16px;
    font-size: 12px;
    cursor: pointer;
    user-select: none;
  }
  .monitor-collapsed:hover { background: var(--bar-bg); }
  .monitor-collapsed .status { font-weight: bold; }
  .monitor-collapsed .status-live { color: var(--green); }
  .monitor-collapsed .status-waiting { color: var(--yellow); }
  .monitor-collapsed .status-ended { color: var(--muted); }
  .monitor-collapsed .token { color: var(--fg); }
  .monitor-collapsed .countdown { color: var(--fg); }
  .monitor-collapsed .stat { color: var(--muted); }
  .monitor-collapsed .stat span { color: var(--fg); }
  .monitor-collapsed .expand { color: var(--dim); margin-left: auto; }

  /* Expanded */
  .monitor-expanded {
    padding: 12px 16px;
    line-height: 1.6;
  }
  .monitor-expanded .head {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 4px;
    cursor: pointer;
    user-select: none;
  }
  .monitor-expanded .head:hover .collapse-hint { color: var(--fg); }
  .monitor-expanded .status { font-weight: bold; }
  .monitor-expanded .status-live { color: var(--green); }
  .monitor-expanded .status-waiting { color: var(--yellow); }
  .monitor-expanded .status-ended { color: var(--muted); }
  .monitor-expanded .token-name { font-size: 15px; }
  .monitor-expanded .countdown { font-size: 18px; letter-spacing: 1px; margin: 4px 0; }
  .collapse-hint { color: var(--dim); font-size: 11px; margin-left: auto; }
  .strategy-btn { background: none; border: none; cursor: pointer; font-size: 13px; padding: 2px 6px; color: var(--muted); line-height: 1; }
  .strategy-btn:hover { color: var(--fg); }
  .strategy-btn.remove:hover { color: var(--red); }
  .strategy-actions { margin-left: auto; display: flex; gap: 2px; align-items: center; }
  .sell-buttons { display: flex; gap: 4px; margin-top: 6px; }
  .sell-btn { background: var(--bar-bg); border: 1px solid var(--border); border-radius: 3px; color: var(--muted); font-size: 11px; padding: 3px 10px; cursor: pointer; }
  .sell-btn:hover { color: var(--red); border-color: var(--red); }
  .sell-btn.selling { color: var(--yellow); border-color: var(--yellow); cursor: wait; }
  .progress-bar {
    height: 4px;
    background: var(--bar-bg);
    margin: 6px 0 2px 0;
  }
  .progress-fill {
    height: 100%;
    background: var(--bar-fill);
    transition: width 0.5s ease;
  }
  .progress-labels {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    color: var(--muted);
  }
  .stats-row {
    display: flex;
    gap: 24px;
    margin-top: 8px;
    font-size: 12px;
  }
  .stats-row .label { color: var(--muted); }
  .bids-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 11px;
    margin-top: 8px;
  }
  .bids-table th {
    text-align: left;
    color: var(--muted);
    font-weight: 400;
    padding: 2px 8px 2px 0;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-size: 10px;
  }
  .bids-table td {
    padding: 2px 8px 2px 0;
    border-bottom: 1px solid var(--border);
  }

  /* Toast notifications */
  #toast-container {
    position: fixed;
    top: 48px;
    right: 16px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 360px;
  }
  .toast {
    background: var(--bar-bg);
    border: 1px solid var(--border);
    border-left: 3px solid var(--yellow);
    padding: 10px 14px;
    font-size: 12px;
    line-height: 1.5;
    animation: slideIn 0.3s ease;
    position: relative;
  }
  .toast.all-good { border-left-color: var(--green); }
  .toast .toast-close {
    position: absolute;
    top: 4px;
    right: 8px;
    background: none;
    border: none;
    color: var(--muted);
    font-size: 14px;
    cursor: pointer;
    font-family: inherit;
  }
  .toast .toast-close:hover { color: var(--fg); }
  .toast .toast-title { font-weight: bold; margin-bottom: 4px; }
  .toast .check-ok { color: var(--green); }
  .toast .check-fail { color: var(--red); }
  @keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }

  /* Login overlay */
  #login-overlay {
    position: fixed;
    inset: 0;
    background: var(--bg);
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 12px;
  }
  #login-overlay.hidden { display: none; }
  #login-overlay input {
    background: var(--bar-bg);
    border: 1px solid var(--border);
    color: var(--fg);
    font-family: inherit;
    font-size: 14px;
    padding: 8px 14px;
    width: 260px;
    outline: none;
  }
  #login-overlay input:focus { border-color: var(--fg); }
  #login-overlay .login-err { color: var(--red); font-size: 12px; min-height: 16px; }

  /* Input bar */
  .inputbar {
    border-top: 1px solid var(--border);
    padding: 8px 16px;
    display: flex;
    align-items: center;
    flex-shrink: 0;
  }
  .inputbar .prompt { color: var(--green); margin-right: 8px; }
  .inputbar input {
    flex: 1;
    background: none;
    border: none;
    color: var(--fg);
    font-family: inherit;
    font-size: 13px;
    outline: none;
    caret-color: var(--fg);
  }
</style>
</head>
<body>

<div id="login-overlay" class="hidden">
  <span style="color:var(--muted)">terminal.flow.bid</span>
  <input type="password" id="login-input" placeholder="password" autocomplete="off">
  <span class="login-err" id="login-err"></span>
</div>

<div class="topbar">
  <span class="title"><span style="color:var(--green)">&gt;</span> TERMINAL</span>
  <span class="wallet" id="wallet"></span>
  <button onclick="toggleTheme()" id="theme-toggle" title="Toggle theme">&#9790;</button>
</div>

<div class="tabbar">
  <div class="tab" data-tab="trade" onclick="switchTab('trade')">TRADE</div>
  <div class="tab" data-tab="flow" onclick="switchTab('flow')">FLOW</div>
  <div class="tab" data-tab="portfolio" onclick="switchTab('portfolio')">PORTFOLIO</div>
  <div class="tab" data-tab="history" onclick="switchTab('history')">HISTORY</div>
</div>

<div class="tab-content" id="tab-trade">
  <div id="monitor-trade" class="tab-monitor"></div>
  <div id="output-trade" class="tab-output"></div>
</div>
<div class="tab-content" id="tab-flow">
  <div id="monitor-flow" class="tab-monitor"></div>
  <div id="output-flow" class="tab-output"></div>
</div>
<div class="tab-content" id="tab-portfolio">
  <div id="monitor-portfolio" class="tab-monitor"></div>
  <div id="output-portfolio" class="tab-output"></div>
</div>
<div class="tab-content" id="tab-history">
  <div id="history-content" class="tab-output"></div>
</div>

<div id="toast-container"></div>

<div class="inputbar">
  <span class="prompt">&gt;</span>
  <input type="text" id="cli" autofocus autocomplete="off" spellcheck="false"
         placeholder="Cmd+/ for help">
</div>

<script>
// ─── Auth ───
let authToken = localStorage.getItem('authToken') || '';

// Wrap fetch to inject auth header
const _origFetch = window.fetch;
window.fetch = function(url, opts = {}) {
  if (authToken && typeof url === 'string' && url.startsWith('/api')) {
    opts.headers = { ...opts.headers, 'Authorization': 'Bearer ' + authToken };
  }
  return _origFetch.call(this, url, opts);
};

async function checkAuth() {
  // Try a lightweight API call to see if auth is required / valid
  const res = await _origFetch('/api/block', authToken ? {
    headers: { 'Authorization': 'Bearer ' + authToken }
  } : {});
  if (res.status === 401) {
    // Auth required — show login
    document.getElementById('login-overlay').classList.remove('hidden');
    const loginInput = document.getElementById('login-input');
    loginInput.focus();
    loginInput.addEventListener('keydown', async (e) => {
      if (e.key !== 'Enter') return;
      const pw = loginInput.value.trim();
      if (!pw) return;
      const test = await _origFetch('/api/block', {
        headers: { 'Authorization': 'Bearer ' + pw }
      });
      if (test.status === 401) {
        document.getElementById('login-err').textContent = 'wrong password';
        loginInput.value = '';
        return;
      }
      authToken = pw;
      localStorage.setItem('authToken', pw);
      document.getElementById('login-overlay').classList.add('hidden');
      boot();
    });
    return false;
  }
  return true;
}

// ─── State ───
let pollInterval = null;
let agentState = { watching: null, status: 'idle', armedBid: null, lastResult: null };
let launchesCache = []; // cached from last `auctions` or boot
let strategiesCache = []; // cached from last poll
let exitStrategiesCache = []; // cached from last poll
let tradingStrategiesCache = []; // cached from last poll
let ethPriceUsd = 2500; // ETH/USD price for gas fee display, updated from topbar
let lastSuggestions = []; // last suggest command results for numeric selection
let activeTab = localStorage.getItem('activeTab') || 'trade';

function q96ToFdv(q96, info) {
  const floor = parseFloat(info.floorPrice || '0');
  if (floor <= 0) return 0;
  const req = parseFloat(info.requiredCurrencyRaised || '0') / 1e6;
  const auction = parseFloat(info.auctionAmount || '0') / 1e18;
  const supply = parseFloat(info.totalSupply || '0') / 1e18;
  if (!auction || !supply || !req) return 0;
  return q96 * ((req / auction) * supply) / floor;
}

// ─── DOM refs ───
const $outputs = {
  flow: document.getElementById('output-flow'),
  trade: document.getElementById('output-trade'),
  portfolio: document.getElementById('output-portfolio'),
  history: document.getElementById('history-content'),
};
const $monitors = {
  flow: document.getElementById('monitor-flow'),
  trade: document.getElementById('monitor-trade'),
  portfolio: document.getElementById('monitor-portfolio'),
};
const $cli = document.getElementById('cli');

// ─── Tab switching ───
function switchTab(name) {
  activeTab = name;
  localStorage.setItem('activeTab', name);
  document.querySelectorAll('.tab').forEach(t => {
    t.classList.toggle('active', t.dataset.tab === name);
  });
  document.querySelectorAll('.tab-content').forEach(tc => {
    tc.classList.toggle('active', tc.id === 'tab-' + name);
  });
  const $out = $outputs[name];
  if ($out) $out.scrollTop = $out.scrollHeight;
  if (name === 'history') renderHistory();
  $cli.focus();
}

// Initialize tab from localStorage
switchTab(activeTab);

// ─── Command routing ───
const TAB_COMMANDS = {
  flow: new Set(['auctions','ls','watch','unwatch','stop','arm','disarm','bid',
    'strategy','strategies','cancel','exit','exits','exit-cancel',
    'claim','claim-all','launch','info','price']),
  trade: new Set(['trade','trades','trade-cancel','trade-remove','trade-pause','trade-resume','liquidate','suggest']),
  portfolio: new Set(['wallet','bids']),
};
const GLOBAL_COMMANDS = new Set(['help','status','clear']);
const TAB_LABELS = { flow: 'Flow', trade: 'Trade', portfolio: 'Portfolio', history: 'History' };
const TAB_KEYS = { trade: '1', flow: '2', portfolio: '3', history: '4' };

function commandTab(cmd) {
  for (const [tab, cmds] of Object.entries(TAB_COMMANDS)) {
    if (cmds.has(cmd)) return tab;
  }
  return null;
}

// ─── Resolve auction identifier (address, symbol, name, or #index) ───
async function resolveAuction(input) {
  if (!input) return null;
  // If it looks like an address, use directly
  if (input.startsWith('0x') && input.length > 10) return input;
  // Otherwise resolve from launches
  if (launchesCache.length === 0) {
    const res = await fetch('/api/launches');
    launchesCache = await res.json();
  }
  // Try by index (1-based)
  const idx = parseInt(input);
  if (!isNaN(idx) && idx >= 1 && idx <= launchesCache.length) {
    return launchesCache[idx - 1].auction;
  }
  // Try by symbol or name (case-insensitive)
  const lower = input.toLowerCase();
  const match = launchesCache.find(l =>
    l.tokenSymbol.toLowerCase() === lower ||
    l.tokenName.toLowerCase().includes(lower)
  );
  if (match) return match.auction;
  return null;
}

function launchLabel(l) {
  return `${l.tokenSymbol} (${l.tokenName})`;
}

// ─── Output helpers ───
function print(text, cls) {
  const $out = $outputs[activeTab];
  const div = document.createElement('div');
  div.className = 'line' + (cls ? ' ' + cls : '');
  div.textContent = text;
  $out.appendChild(div);
  $out.scrollTop = $out.scrollHeight;
}

function printHtml(html) {
  const $out = $outputs[activeTab];
  const div = document.createElement('div');
  div.className = 'line';
  div.innerHTML = html;
  $out.appendChild(div);
  $out.scrollTop = $out.scrollHeight;
}

function printTo(tab, text, cls) {
  const $out = $outputs[tab];
  if (!$out) return;
  const div = document.createElement('div');
  div.className = 'line' + (cls ? ' ' + cls : '');
  div.textContent = text;
  $out.appendChild(div);
  $out.scrollTop = $out.scrollHeight;
}

// ─── Monitor state (per auction) ───
const monitorCollapsed = {}; // addr -> bool
const collapsedStrategies = new Set(); // strategy id -> collapsed
const monitorData = {};      // addr -> { info, bids }

function toggleMonitor(addr) {
  monitorCollapsed[addr] = !monitorCollapsed[addr];
  renderAllMonitors();
}

function toggleStrategy(id) {
  if (collapsedStrategies.has(id)) collapsedStrategies.delete(id);
  else collapsedStrategies.add(id);
  renderTradeMonitors();
}

async function removeStrategy(id, ev) {
  ev.stopPropagation();
  const s = tradingStrategiesCache.find(s => s.id === id);
  const isActive = s && (s.status === 'running' || s.status === 'paused');
  if (isActive && !confirm(`Cancel and remove ${s.type.toUpperCase()} ${s.tokenSymbol} (#${id})?`)) return;
  try {
    if (isActive) {
      const cr = await fetch(`/api/trading-strategy/${id}/cancel`, { method: 'POST' });
      const cd = await cr.json();
      if (cd.error) throw new Error(cd.error);
    }
    const res = await fetch(`/api/trading-strategy/${id}`, { method: 'DELETE' });
    const data = await res.json();
    if (data.error) throw new Error(data.error);
    tradingStrategiesCache = tradingStrategiesCache.filter(s => s.id !== id);
    renderTradeMonitors();
  } catch (e) {
    print('remove failed: ' + e.message, 'err');
  }
}

async function sellPosition(id, pct, btn) {
  if (btn) { btn.classList.add('selling'); btn.textContent = 'selling...'; }
  try {
    const res = await fetch(`/api/trading-strategy/${id}/sell`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ pct }),
    });
    const data = await res.json();
    if (data.error) throw new Error(data.error);
    print(`sold ${data.sold}`, 'ok');
  } catch (e) {
    print('sell failed: ' + e.message, 'err');
  }
  if (btn) { btn.classList.remove('selling'); btn.textContent = pct === 100 ? 'ALL' : pct + '%'; }
}

function renderAllMonitors() {
  renderFlowMonitors();
  renderTradeMonitors();
  renderPortfolioMonitor();
}

function renderFlowMonitors() {
  const $mon = $monitors.flow;
  const addrs = agentState.watching || [];
  if (addrs.length === 0) {
    $mon.classList.remove('active');
    $mon.innerHTML = '';
    return;
  }
  $mon.classList.add('active');
  let html = '';
  addrs.forEach(addr => {
    const d = monitorData[addr];
    if (!d) return;
    html += renderOneMonitor(addr, d.info, d.bids, d.block);
  });
  $mon.innerHTML = html;
}

function renderTradeMonitors() {
  const $mon = $monitors.trade;
  const hasTrading = Array.isArray(tradingStrategiesCache) && tradingStrategiesCache.length > 0;
  if (!hasTrading) {
    $mon.classList.remove('active');
    $mon.innerHTML = '';
    return;
  }
  $mon.classList.add('active');
  $mon.innerHTML = renderTradingStrategies();
}

function renderPortfolioMonitor() {
  const $mon = $monitors.portfolio;
  if (!Array.isArray(tradingStrategiesCache) || tradingStrategiesCache.length === 0) {
    $mon.classList.remove('active');
    $mon.innerHTML = '';
    return;
  }

  let totalInvested = 0;
  let totalValue = 0;
  let totalRealized = 0;
  let totalUnrealized = 0;
  const tokens = [];
  const allTrades = [];

  tradingStrategiesCache.forEach(s => {
    const lastPrice = s.priceHistory.length > 0 ? s.priceHistory[s.priceHistory.length - 1].price : 0;
    const value = s.position.tokenBalance * lastPrice;
    totalInvested += s.position.totalInvested;
    totalValue += value;
    totalRealized += s.pnl.realized;
    totalUnrealized += s.pnl.unrealized;

    tokens.push({
      symbol: s.tokenSymbol,
      balance: s.position.tokenBalance,
      avgEntry: s.position.avgEntryPrice,
      lastPrice,
      value,
      pnlTotal: s.pnl.realized + s.pnl.unrealized,
      pnlPct: s.position.totalInvested > 0 ? ((s.pnl.realized + s.pnl.unrealized) / s.position.totalInvested * 100) : 0,
    });

    if (s.trades) {
      s.trades.forEach(t => allTrades.push({ ...t, symbol: s.tokenSymbol }));
    }
  });

  const totalPnl = totalRealized + totalUnrealized;
  const totalPnlPct = totalInvested > 0 ? (totalPnl / totalInvested * 100) : 0;
  const pnlColor = totalPnl >= 0 ? 'var(--green)' : 'var(--red)';

  let h = '<div class="monitor-expanded">';
  h += '<div class="head"><span class="token-name">Portfolio Summary</span></div>';

  h += '<div class="stats-row">';
  h += `<span><span class="label">invested</span> ${fmtUsd(totalInvested)}</span>`;
  h += `<span><span class="label">value</span> ${fmtUsd(totalValue)}</span>`;
  h += `<span style="color:${pnlColor}"><span class="label">total pnl</span> ${totalPnl >= 0 ? '+' : ''}${fmtUsd(totalPnl)} (${totalPnlPct >= 0 ? '+' : ''}${totalPnlPct.toFixed(1)}%)</span>`;
  h += `<span><span class="label">realized</span> ${fmtUsd(totalRealized)}</span>`;
  h += '</div>';

  // Per-token table
  if (tokens.length > 0) {
    h += '<table class="bids-table"><tr><th>token</th><th>balance</th><th>avg entry</th><th>price</th><th>value</th><th>pnl</th></tr>';
    tokens.forEach(t => {
      const tColor = t.pnlTotal >= 0 ? 'var(--green)' : 'var(--red)';
      h += '<tr>';
      h += `<td>${t.symbol}</td>`;
      h += `<td>${fmtNum(t.balance)}</td>`;
      h += `<td>$${t.avgEntry.toFixed(6)}</td>`;
      h += `<td>${t.lastPrice > 0 ? '$' + t.lastPrice.toFixed(6) : '\u2014'}</td>`;
      h += `<td>${fmtUsd(t.value)}</td>`;
      h += `<td style="color:${tColor}">${t.pnlTotal >= 0 ? '+' : ''}${fmtUsd(t.pnlTotal)} (${t.pnlPct >= 0 ? '+' : ''}${t.pnlPct.toFixed(1)}%)</td>`;
      h += '</tr>';
    });
    h += '</table>';
  }

  // Recent trades (last 10 across all strategies)
  allTrades.sort((a, b) => (b.time || b.timestamp || 0) - (a.time || a.timestamp || 0));
  const recentTrades = allTrades.slice(0, 10);
  if (recentTrades.length > 0) {
    h += '<div style="margin-top:8px;font-size:11px;color:var(--muted)">Recent trades</div>';
    h += '<table class="bids-table"><tr><th>time</th><th>token</th><th>side</th><th>amount</th><th>price</th></tr>';
    recentTrades.forEach(t => {
      const time = t.time || t.timestamp;
      const ago = time ? fmtTimeAgo(Math.round((Date.now() - time) / 1000)) : '\u2014';
      const sideColor = t.side === 'buy' ? 'var(--green)' : 'var(--red)';
      h += '<tr>';
      h += `<td>${ago}</td>`;
      h += `<td>${t.symbol}</td>`;
      h += `<td style="color:${sideColor}">${(t.side || '\u2014').toUpperCase()}</td>`;
      h += `<td>${t.amountUsd ? fmtUsd(t.amountUsd) : t.amount ? fmtUsd(t.amount) : '\u2014'}</td>`;
      h += `<td>${t.price ? '$' + t.price.toFixed(6) : '\u2014'}</td>`;
      h += '</tr>';
    });
    h += '</table>';
  }

  h += '</div>';

  $mon.classList.add('active');
  $mon.innerHTML = h;
}

function renderTradingStrategies() {
  let h = '';
  tradingStrategiesCache.forEach(s => {
    const statusColor = s.status === 'running' ? 'var(--green)' : s.status === 'paused' ? 'var(--yellow)' : 'var(--muted)';
    const lastPrice = s.priceHistory.length > 0 ? s.priceHistory[s.priceHistory.length - 1].price : 0;
    const posValue = s.position.tokenBalance * lastPrice;
    const pnlTotal = s.pnl.realized + s.pnl.unrealized;
    const pnlColor = pnlTotal >= 0 ? 'var(--green)' : 'var(--red)';
    const pnlPct = s.position.totalInvested > 0 ? (pnlTotal / s.position.totalInvested * 100) : 0;
    const eid = s.id.replace(/'/g, "\\'");
    const collapsed = collapsedStrategies.has(s.id);

    if (collapsed) {
      const cGasUsd = (s.totalGasCostEth || 0) * ethPriceUsd;
      const cTruePnl = pnlTotal - cGasUsd;
      const cTruePnlColor = cTruePnl >= 0 ? 'var(--green)' : 'var(--red)';
      h += `<div class="monitor-collapsed" onclick="toggleStrategy('${eid}')">`;
      h += `<span class="status" style="color:${statusColor}">${s.status.toUpperCase()}</span>`;
      h += `<span class="token">${s.type.toUpperCase()} ${s.tokenSymbol}</span>`;
      h += `<span class="stat"><span class="label">#</span><span>${s.id}</span></span>`;
      h += `<span style="color:${cTruePnlColor}" class="stat"><span class="label">pnl </span><span>${cTruePnl >= 0 ? '+' : ''}${fmtUsd(cTruePnl)}</span></span>`;
      h += `<button class="strategy-btn remove" onclick="removeStrategy('${eid}', event)" title="Remove strategy">&#10005;</button>`;
      h += `<span class="expand">&#9660;</span>`;
      h += `</div>`;
      return;
    }

    h += `<div class="monitor-expanded" style="border-top:1px solid var(--border)">`;
    h += `<div class="head" onclick="toggleStrategy('${eid}')">`;
    h += `<span class="status" style="color:${statusColor}">${s.status.toUpperCase()}</span>`;
    h += `<span class="token-name">${s.type.toUpperCase()} ${s.tokenSymbol}</span>`;
    h += `<span style="color:var(--muted);font-size:11px">#${s.id}</span>`;
    h += `<button class="strategy-btn remove" onclick="removeStrategy('${eid}', event)" title="Remove strategy">&#10005;</button>`;
    h += `<span class="collapse-hint">&#9650;</span>`;
    h += `</div>`;

    h += `<div class="stats-row">`;
    h += `<span><span class="label">position</span> ${fmtNum(s.position.tokenBalance)} ${s.tokenSymbol}</span>`;
    h += `<span><span class="label">value</span> ${fmtUsd(posValue)}</span>`;
    h += `<span><span class="label">avg entry</span> $${s.position.avgEntryPrice.toFixed(6)}</span>`;
    if (lastPrice > 0) h += `<span><span class="label">price</span> $${lastPrice.toFixed(6)}</span>`;
    h += `<span style="color:${pnlColor}"><span class="label">pnl</span> ${pnlTotal >= 0 ? '+' : ''}${fmtUsd(pnlTotal)} (${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(1)}%)</span>`;
    h += `</div>`;

    h += `<div class="stats-row">`;
    const gasEth = s.totalGasCostEth || 0;
    const gasUsd = gasEth * ethPriceUsd;
    const truePnl = pnlTotal - gasUsd;
    const truePnlColor = truePnl >= 0 ? 'var(--green)' : 'var(--red)';
    const truePnlPct = s.position.totalInvested > 0 ? (truePnl / s.position.totalInvested * 100) : 0;

    h += `<span><span class="label">invested</span> ${fmtUsd(s.position.totalInvested)}</span>`;
    h += `<span><span class="label">realized</span> ${fmtUsd(s.position.totalRealized)}</span>`;
    h += `<span><span class="label">trades</span> ${s.trades.length}</span>`;
    h += `<span style="color:var(--red)"><span class="label">stop-loss</span> ${s.riskLimits.stopLossPercent}%</span>`;
    h += `</div>`;

    h += `<div class="stats-row">`;
    h += `<span style="color:var(--yellow)"><span class="label">gas fees</span> ${gasEth.toFixed(5)} ETH (~${fmtUsd(gasUsd)})</span>`;
    h += `<span style="color:${truePnlColor}"><span class="label">true pnl</span> ${truePnl >= 0 ? '+' : ''}${fmtUsd(truePnl)} (${truePnlPct >= 0 ? '+' : ''}${truePnlPct.toFixed(1)}%)</span>`;
    h += `</div>`;

    // Sell buttons (only if there's a position)
    if (s.position.tokenBalance > 0) {
      h += `<div class="sell-buttons">`;
      h += `<span class="label" style="line-height:22px">sell</span>`;
      for (const pct of [25, 50, 75, 100]) {
        const label = pct === 100 ? 'ALL' : pct + '%';
        h += `<button class="sell-btn" onclick="sellPosition('${eid}', ${pct}, this)">${label}</button>`;
      }
      h += `</div>`;
    }

    // Sparkline from price history
    if (s.priceHistory.length > 1) {
      h += `<div style="font-size:11px;color:var(--muted);margin-top:4px;">`;
      h += `<span class="label">price </span>${renderSparkline(s.priceHistory)}`;
      h += `</div>`;
    }

    // Last 3 log entries
    if (s.log && s.log.length > 0) {
      const recent = s.log.slice(-3);
      recent.forEach(l => {
        const ago = Math.round((Date.now() - l.time) / 1000);
        const logColor = l.type === 'error' ? 'var(--red)' : l.type === 'trade' ? 'var(--green)' : 'var(--muted)';
        h += `<div style="font-size:11px;color:${logColor}">${l.message} (${fmtTimeAgo(ago)})</div>`;
      });
    }

    h += `</div>`;
  });
  return h;
}

function renderHistory() {
  const $el = document.getElementById('history-content');
  if (!$el) return;
  if (!tradingStrategiesCache.length) {
    $el.innerHTML = '<div class="line dim">no trade history</div>';
    return;
  }

  let h = '';

  // Summary across all strategies
  let totalInvested = 0, totalRealized = 0, totalPosValue = 0, totalGasEth = 0, totalTrades = 0;
  tradingStrategiesCache.forEach(s => {
    totalInvested += s.position.totalInvested;
    totalRealized += s.position.totalRealized;
    totalGasEth += s.totalGasCostEth || 0;
    totalTrades += s.trades.length;
    const lastPrice = s.priceHistory.length > 0 ? s.priceHistory[s.priceHistory.length - 1].price : 0;
    totalPosValue += s.position.tokenBalance * lastPrice;
  });
  const totalGasUsd = totalGasEth * ethPriceUsd;
  const rawPnl = (totalRealized + totalPosValue) - totalInvested;
  const truePnl = rawPnl - totalGasUsd;
  const truePnlColor = truePnl >= 0 ? 'var(--green)' : 'var(--red)';

  h += `<div style="margin-bottom:12px;line-height:1.8">`;
  h += `<div><span class="label" style="color:var(--muted)">SUMMARY</span></div>`;
  h += `<div><span class="label">total invested</span> ${fmtUsd(totalInvested)}</div>`;
  h += `<div><span class="label">realized</span> ${fmtUsd(totalRealized)}`;
  if (totalPosValue > 0) h += `  <span class="label">open positions</span> ${fmtUsd(totalPosValue)}`;
  h += `</div>`;
  h += `<div><span class="label">raw pnl</span> <span style="color:${rawPnl >= 0 ? 'var(--green)' : 'var(--red)'}">${rawPnl >= 0 ? '+' : ''}${fmtUsd(rawPnl)}</span></div>`;
  h += `<div><span class="label">gas fees</span> <span style="color:var(--yellow)">${totalGasEth.toFixed(5)} ETH (~${fmtUsd(totalGasUsd)})</span></div>`;
  h += `<div><span class="label">true pnl</span> <span style="color:${truePnlColor};font-weight:bold">${truePnl >= 0 ? '+' : ''}${fmtUsd(truePnl)}</span></div>`;
  h += `<div><span class="label">total trades</span> ${totalTrades}</div>`;
  h += `</div>`;

  // Per-strategy breakdown
  tradingStrategiesCache.forEach(s => {
    const gasEth = s.totalGasCostEth || 0;
    const gasUsd = gasEth * ethPriceUsd;
    const sPnl = s.pnl.realized + s.pnl.unrealized;
    const sTruePnl = sPnl - gasUsd;
    const sTrueColor = sTruePnl >= 0 ? 'var(--green)' : 'var(--red)';
    const statusColor = s.status === 'running' ? 'var(--green)' : s.status === 'paused' ? 'var(--yellow)' : 'var(--muted)';

    h += `<div style="border-top:1px solid var(--border);padding:8px 0;line-height:1.6">`;
    h += `<div><span style="color:${statusColor};font-weight:bold">${s.status.toUpperCase()}</span> ${s.type.toUpperCase()} ${s.tokenSymbol} <span style="color:var(--muted)">#${s.id}</span></div>`;
    h += `<div><span class="label">invested</span> ${fmtUsd(s.position.totalInvested)}`;
    h += `  <span class="label">realized</span> ${fmtUsd(s.position.totalRealized)}`;
    h += `  <span class="label">gas</span> <span style="color:var(--yellow)">${gasEth.toFixed(5)} ETH (~${fmtUsd(gasUsd)})</span>`;
    h += `  <span class="label">true pnl</span> <span style="color:${sTrueColor}">${sTruePnl >= 0 ? '+' : ''}${fmtUsd(sTruePnl)}</span></div>`;

    // Trade list
    if (s.trades.length > 0) {
      h += `<table style="font-size:11px;width:100%;margin-top:4px;border-collapse:collapse">`;
      h += `<tr style="color:var(--muted)"><td>time</td><td>side</td><td>amount</td><td>price</td><td>gas</td><td>tx</td></tr>`;
      s.trades.slice().reverse().forEach(t => {
        const sideColor = t.side === 'buy' ? 'var(--green)' : 'var(--red)';
        const time = new Date(t.timestamp).toLocaleString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
        const gasStr = t.gasCostEth ? `${t.gasCostEth.toFixed(5)}` : '-';
        h += `<tr>`;
        h += `<td style="color:var(--muted)">${time}</td>`;
        h += `<td style="color:${sideColor}">${t.side.toUpperCase()}</td>`;
        h += `<td>${fmtUsd(t.amountUsdc)} / ${fmtNum(t.amountToken)} ${s.tokenSymbol}</td>`;
        h += `<td>$${t.price.toFixed(6)}</td>`;
        h += `<td style="color:var(--yellow)">${gasStr}</td>`;
        h += `<td><a href="https://basescan.org/tx/${t.txHash}" target="_blank" style="color:var(--cyan)">${t.txHash.slice(0, 8)}</a></td>`;
        h += `</tr>`;
      });
      h += `</table>`;
    }

    h += `</div>`;
  });

  $el.innerHTML = h;
}

function fmtNum(n) {
  if (n >= 1000000) return (n / 1000000).toFixed(2) + 'M';
  if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
  if (n >= 1) return n.toFixed(2);
  return n.toFixed(6);
}

function fmtTimeAgo(seconds) {
  if (seconds < 60) return seconds + 's ago';
  if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
  return Math.floor(seconds / 3600) + 'h ago';
}

function renderSparkline(priceHistory) {
  const prices = priceHistory.slice(-40).map(p => p.price);
  const min = Math.min(...prices);
  const max = Math.max(...prices);
  const range = max - min || 1;
  const chars = '\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588';
  return prices.map(p => {
    const idx = Math.min(7, Math.floor(((p - min) / range) * 7));
    return chars[idx];
  }).join('');
}

function analyzeToken(history) {
  const prices = history.map(p => p.price);
  const n = prices.length;
  const currentPrice = prices[n - 1];
  const high = Math.max(...prices);
  const low = Math.min(...prices);
  const rangePct = low > 0 ? ((high - low) / low) * 100 : 0;

  // 30s returns for volatility
  const returns = [];
  for (let i = 1; i < n; i++) {
    if (prices[i - 1] > 0) returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
  }
  const mean = returns.reduce((a, b) => a + b, 0) / (returns.length || 1);
  const variance = returns.reduce((a, r) => a + (r - mean) ** 2, 0) / (returns.length || 1);
  const volatility = Math.sqrt(variance);
  // Annualize to hourly: 120 intervals per hour (30s each)
  const hourlyVolPct = volatility * Math.sqrt(120) * 100;

  // Trend: avg of last 1h vs avg of last 4h
  const pts1h = Math.min(120, n);
  const pts4h = Math.min(480, n);
  const avg1h = prices.slice(-pts1h).reduce((a, b) => a + b, 0) / pts1h;
  const avg4h = prices.slice(-pts4h).reduce((a, b) => a + b, 0) / pts4h;
  const trendPct = avg4h > 0 ? ((avg1h - avg4h) / avg4h) * 100 : 0;

  // Support/resistance: last 2h (240 points)
  const recent = prices.slice(-Math.min(240, n));
  const support = Math.min(...recent);
  const resistance = Math.max(...recent);

  return { volatility, hourlyVolPct, trendPct, rangePct, high, low, currentPrice, support, resistance };
}

function renderOneMonitor(addr, info, bids, block) {
  // Estimate current block by adding elapsed time since last poll
  const elapsed = (Date.now() - lastPollTime) / 1000;
  const currentBlock = block.blockNumber + Math.floor(elapsed / 2);
  const startBlock = parseInt(info.startBlock) || 0;
  const endBlock = parseInt(info.endBlock) || (startBlock + 270);
  const duration = endBlock - startBlock;

  let status, statusCls;
  if (currentBlock < startBlock) {
    status = 'WAITING';
    statusCls = 'status-waiting';
  } else if (currentBlock < endBlock) {
    status = 'LIVE';
    statusCls = 'status-live';
  } else {
    status = 'ENDED';
    statusCls = 'status-ended';
  }

  const tokenName = info.tokenName || info.name || info.token?.name || '';
  const tokenSymbol = info.tokenSymbol || info.symbol || info.token?.symbol || '';

  let countdownShort = '';
  let countdownFull = '';
  if (status === 'WAITING') {
    const left = startBlock - currentBlock;
    countdownShort = fmtTime(left * 2);
    countdownFull = `starts in ${countdownShort}  (${left} blocks)`;
  } else if (status === 'LIVE') {
    const left = endBlock - currentBlock;
    countdownShort = fmtTime(left * 2);
    countdownFull = `${countdownShort} remaining  (${left} blocks)`;
  } else {
    countdownShort = 'ended';
    countdownFull = 'auction ended';
  }

  let progress = 0;
  if (status === 'LIVE') progress = Math.min(100, ((currentBlock - startBlock) / duration) * 100);
  else if (status === 'ENDED') progress = 100;

  const bidList = Array.isArray(bids) ? bids : [];
  const totalBids = (info.stats && info.stats.totalBids) || bidList.length;
  const bidders = (info.stats && info.stats.uniqueBidders) || new Set(bidList.map(b => b.owner || '')).size;
  const raisedRaw = parseFloat(info.currencyRaised || '0');
  const raised = raisedRaw / 1e6;
  const requiredRaised = parseFloat(info.requiredCurrencyRaised || '0') / 1e6;

  const clearingQ96 = parseFloat(info.clearingPrice || '0');
  const fdv = clearingQ96 > 0 ? q96ToFdv(clearingQ96, info) : null;
  const armedBids = agentState.armedBids || [];
  const armedBid = armedBids.find(b => b.auctionAddress === addr);
  const isArmed = !!armedBid;
  const strategy = strategiesCache.find(s => s.auctionAddress === addr && (s.status === 'watching' || s.status === 'bidding' || s.status === 'waiting'));

  // Escaped addr for onclick
  const esc = addr.replace(/'/g, "\\'");

  // ── Collapsed ──
  if (monitorCollapsed[addr]) {
    let h = `<div class="monitor-collapsed" onclick="toggleMonitor('${esc}')">`;
    h += `<span class="status ${statusCls}">${status}</span>`;
    h += `<span class="token">${tokenSymbol || tokenName}</span>`;
    h += `<span class="countdown">${countdownShort}</span>`;
    h += `<span class="stat"><span class="label">bids </span><span>${totalBids}</span></span>`;
    h += `<span class="stat"><span class="label">raised </span><span>${fmtUsd(raised)}${requiredRaised > 0 ? ' / ' + fmtUsd(requiredRaised) : ''}</span></span>`;
    if (fdv) h += `<span class="stat"><span class="label">fdv </span><span>${fmtUsd(fdv)}</span></span>`;
    if (strategy) h += `<span style="color:var(--green)">STRATEGY ${strategy.status}</span>`;
    const exitStrat = exitStrategiesCache.find(e => e.auctionAddress === addr);
    if (exitStrat) {
      const exitColor = exitStrat.status === 'stopped' ? 'var(--red)' : 'var(--cyan)';
      h += `<span style="color:${exitColor}">EXIT ${exitStrat.status === 'stopped' ? 'STOPPED' : exitStrat.currentMultiple.toFixed(1) + 'x'} ${fmtUsd(exitStrat.totalUsdcRealized)}</span>`;
    }
    if (isArmed) h += `<span style="color:var(--green)">ARMED</span>`;
    h += `<span class="expand">&#9660;</span>`;
    h += `</div>`;
    return h;
  }

  // ── Expanded ──
  let h = `<div class="monitor-expanded">`;
  h += `<div class="head" onclick="toggleMonitor('${esc}')">`;
  h += `<span class="status ${statusCls}">${status}</span>`;
  h += `<span class="token-name">${tokenName}</span>`;
  if (tokenSymbol) h += `<span style="color:var(--muted)">$${tokenSymbol}</span>`;
  if (isArmed) {
    h += `<span style="color:var(--green)">[ARMED ${armedBid.amount} USDC @ ${fmtUsd(armedBid.maxFdvUsd)} FDV]</span>`;
  }
  h += `<span class="collapse-hint">&#9650;</span>`;
  h += `</div>`;

  h += `<div class="countdown">${countdownFull}</div>`;
  h += `<div class="progress-bar"><div class="progress-fill" style="width:${progress}%"></div></div>`;
  h += `<div class="progress-labels"><span>${startBlock.toLocaleString()}</span><span>${currentBlock.toLocaleString()}</span><span>${endBlock.toLocaleString()}</span></div>`;

  h += `<div class="stats-row">`;
  h += `<span><span class="label">bids</span> ${totalBids}</span>`;
  h += `<span><span class="label">bidders</span> ${bidders}</span>`;
  h += `<span><span class="label">raised</span> ${fmtUsd(raised)}${requiredRaised > 0 ? ' / ' + fmtUsd(requiredRaised) : ''}</span>`;
  if (fdv) h += `<span><span class="label">fdv</span> ${fmtUsd(fdv)}</span>`;
  h += `</div>`;

  if (strategy) {
    const stratColor = strategy.status === 'bidding' ? 'var(--green)' : strategy.status === 'watching' ? 'var(--yellow)' : 'var(--muted)';
    h += `<div class="stats-row">`;
    h += `<span style="color:${stratColor}"><span class="label">strategy</span> ${strategy.status.toUpperCase()}</span>`;
    h += `<span><span class="label">range</span> ${fmtUsd(strategy.minFdvUsd || 0)} \u2013 ${fmtUsd(strategy.maxFdvUsd || 0)}</span>`;
    h += `<span><span class="label">amount</span> ${strategy.amount} USDC</span>`;
    if (strategy.impliedFdv) h += `<span><span class="label">clearing fdv</span> ${fmtUsd(strategy.impliedFdv)}</span>`;
    h += `<span><span class="label">bids placed</span> ${strategy.bidsPlaced}</span>`;
    if (strategy.exitProfile) h += `<span><span class="label">exit</span> ${strategy.exitProfile}</span>`;
    // Show FDV trend during watching phase
    if (strategy.status === 'watching' && strategy.fdvHistory && strategy.fdvHistory.length > 1) {
      const first = strategy.fdvHistory[0];
      const last = strategy.fdvHistory[strategy.fdvHistory.length - 1];
      const trend = last > first ? '\u2191' : last < first ? '\u2193' : '\u2192';
      h += `<span><span class="label">fdv trend</span> ${trend} ${fmtUsd(first)} \u2192 ${fmtUsd(last)}</span>`;
    }
    // Show bid window countdown during watching phase
    if (strategy.status === 'watching' && status === 'LIVE') {
      const bidWindowBlocks = Math.max(0, (endBlock - currentBlock) - 15);
      if (bidWindowBlocks > 0) {
        h += `<span style="color:var(--cyan)"><span class="label">bid window in</span> ${fmtTime(bidWindowBlocks * 2)}</span>`;
      }
    }
    if (strategy.log && strategy.log.length > 0) {
      const lastLog = strategy.log[strategy.log.length - 1];
      const ago = Math.round((Date.now() - lastLog.time) / 1000);
      h += `<span><span class="label">last</span> ${lastLog.message} (${ago}s ago)</span>`;
    }
    h += `</div>`;
  }

  // Exit strategy display
  const exitStrategy = exitStrategiesCache.find(e => e.auctionAddress === addr);
  if (exitStrategy) {
    const multColor = exitStrategy.currentMultiple >= 2 ? 'var(--green)' : exitStrategy.currentMultiple >= 1 ? 'var(--yellow)' : 'var(--red)';
    const exitStatusColor = exitStrategy.status === 'stopped' ? 'var(--red)' : 'var(--cyan)';
    h += `<div class="stats-row">`;
    h += `<span style="color:${exitStatusColor}"><span class="label">exit</span> ${exitStrategy.profileName} ${exitStrategy.status.toUpperCase()}</span>`;
    h += `<span><span class="label">fdv</span> ${fmtUsd(exitStrategy.currentFdv)}</span>`;
    h += `<span style="color:${multColor}"><span class="label">multiple</span> ${exitStrategy.currentMultiple.toFixed(2)}x</span>`;
    h += `<span><span class="label">realized</span> ${fmtUsd(exitStrategy.totalUsdcRealized)}</span>`;
    if (exitStrategy.stopLossMultiple != null) h += `<span style="color:var(--red)"><span class="label">stop-loss</span> ${exitStrategy.stopLossMultiple}x</span>`;
    h += `</div>`;
    // Tranche details
    if (exitStrategy.tranches && exitStrategy.tranches.length > 0) {
      h += `<div class="stats-row" style="flex-wrap:wrap;gap:8px 16px;">`;
      exitStrategy.tranches.forEach((t, i) => {
        const tColor = t.status === 'executed' ? 'var(--green)' : t.status === 'skipped' ? 'var(--dim)' : 'var(--muted)';
        let tText = `${t.pctToSell}% @ ${t.targetMultiple}x`;
        if (t.status === 'executed') tText += ` \u2192 $${t.usdcReceived}`;
        h += `<span style="color:${tColor}">${t.status === 'executed' ? '\u2713' : t.status === 'skipped' ? '\u2717' : '\u25CB'} ${tText}</span>`;
      });
      h += `</div>`;
    }
  }

  if (bidList.length > 0) {
    h += `<table class="bids-table"><tr><th>block</th><th>bidder</th><th>amount</th><th>max fdv</th></tr>`;
    bidList.slice(-8).reverse().forEach(b => {
      const ba = b.owner || '\u2014';
      const short = ba.length > 10 ? ba.slice(0, 6) + '..' + ba.slice(-4) : ba;
      const amtRaw = parseFloat(b.amountBid || '0');
      const amt = amtRaw > 0 ? fmtUsd(amtRaw / 1e6) : '\u2014';
      const maxPriceQ96 = parseFloat(b.maxPrice || '0');
      const bidFdv = maxPriceQ96 > 0 ? q96ToFdv(maxPriceQ96, info) : null;
      const blk = b.submittedAtBlock || '\u2014';
      h += `<tr><td>${blk}</td><td>${short}</td><td>${amt}</td><td>${bidFdv ? fmtUsd(bidFdv) : '\u2014'}</td></tr>`;
    });
    h += `</table>`;
  }

  h += `</div>`;
  return h;
}

// For one-shot info command (renders into output, not the pinned monitor)
function printMonitorToOutput(info, bids, block) {
  const html = renderOneMonitor('_oneshot', info, bids, block);
  const $out = $outputs[activeTab];
  const div = document.createElement('div');
  div.innerHTML = html;
  $out.appendChild(div);
  $out.scrollTop = $out.scrollHeight;
}

// ─── Formatting ───
function fmtTime(seconds) {
  if (seconds <= 0) return 'now';
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = Math.floor(seconds % 60);
  const parts = [];
  if (h > 0) parts.push(h + 'h');
  if (m > 0) parts.push(m + 'm');
  parts.push(s + 's');
  return parts.join(' ');
}

function fmtUsd(n) {
  const num = typeof n === 'string' ? parseFloat(n) : n;
  if (isNaN(num)) return String(n);
  if (num >= 1_000_000) return '$' + (num / 1_000_000).toFixed(2) + 'M';
  if (num >= 1_000) return '$' + (num / 1_000).toFixed(1) + 'K';
  return '$' + num.toFixed(2);
}

function shortAddr(a) {
  return a && a.length > 14 ? a.slice(0, 6) + '...' + a.slice(-4) : a;
}

// ─── Polling (all watched auctions) ───
let tickInterval = null;
let lastPollTime = Date.now();

function startPolling() {
  stopPolling();
  pollAll();
  pollInterval = setInterval(pollAll, 3000);
  // 1-second local ticker for smooth countdowns
  tickInterval = setInterval(renderAllMonitors, 1000);
}

function stopPolling() {
  if (pollInterval) clearInterval(pollInterval);
  if (tickInterval) clearInterval(tickInterval);
  pollInterval = null;
  tickInterval = null;
}

async function pollAll() {
  try {
    const [agentRes, blockRes, stratRes, exitRes, tradingRes, ethPriceRes] = await Promise.all([
      fetch('/api/agent'),
      fetch('/api/block'),
      fetch('/api/strategies'),
      fetch('/api/exit-strategies'),
      fetch('/api/trading-strategies'),
      fetch('/api/token/0x4200000000000000000000000000000000000006/price'),
    ]);
    agentState = await agentRes.json();
    const block = await blockRes.json();
    try { strategiesCache = await stratRes.json(); } catch { strategiesCache = []; }
    try { exitStrategiesCache = await exitRes.json(); } catch { exitStrategiesCache = []; }
    try { tradingStrategiesCache = await tradingRes.json(); } catch { tradingStrategiesCache = []; }
    try { const epd = await ethPriceRes.json(); if (epd.price) ethPriceUsd = epd.price; } catch {}
    tradingStrategiesCache.forEach(s => { if (!collapsedStrategies.has(s.id) && !collapsedStrategies.has('_seen_' + s.id)) { collapsedStrategies.add(s.id); collapsedStrategies.add('_seen_' + s.id); } });
    const addrs = agentState.watching || [];

    const hasActiveTrades = Array.isArray(tradingStrategiesCache) && tradingStrategiesCache.some(s => s.status === 'running' || s.status === 'paused');
    if (addrs.length === 0 && !hasActiveTrades) {
      stopPolling();
      renderAllMonitors();
      return;
    }

    // Fetch info + bids for all watched auctions in parallel
    const results = await Promise.all(addrs.map(async addr => {
      const [infoRes, bidsRes] = await Promise.all([
        fetch(`/api/auction/${addr}`),
        fetch(`/api/auction/${addr}/bids`),
      ]);
      const [info, bids] = await Promise.all([infoRes.json(), bidsRes.json()]);
      return { addr, info, bids };
    }));

    results.forEach(({ addr, info, bids }) => {
      monitorData[addr] = { info, bids, block };
    });

    lastPollTime = Date.now();
    renderAllMonitors();
    checkReadinessAlerts();
  } catch (e) {
    print('poll error: ' + e.message, 'err');
  }
}

// ─── Keyboard shortcuts ───
document.addEventListener('keydown', (e) => {
  if (!e.metaKey && !e.ctrlKey) return;
  const key = e.key.toLowerCase();
  switch (key) {
    case 'k': e.preventDefault(); $outputs[activeTab].innerHTML = ''; break;
    case 'l': e.preventDefault(); switchTab('flow'); runCmd('auctions'); break;
    case 'j': e.preventDefault(); runCmd('status'); break;
    case 'w': e.preventDefault(); switchTab('portfolio'); runCmd('wallet'); break;
    case 'b': e.preventDefault(); switchTab('portfolio'); runCmd('bids'); break;
    case 'm':
      e.preventDefault();
      const addrs = agentState.watching || [];
      if (addrs.length > 0) {
        const allCollapsed = addrs.every(a => monitorCollapsed[a]);
        addrs.forEach(a => monitorCollapsed[a] = !allCollapsed);
        renderAllMonitors();
      }
      break;
    case '/':
      e.preventDefault();
      runCmd('help');
      break;
    case '1': e.preventDefault(); switchTab('trade'); break;
    case '2': e.preventDefault(); switchTab('flow'); break;
    case '3': e.preventDefault(); switchTab('portfolio'); break;
    case '4': e.preventDefault(); switchTab('history'); renderHistory(); break;
  }
});

// ─── CLI ───
$cli.addEventListener('keydown', async (e) => {
  if (e.key !== 'Enter') return;
  const raw = $cli.value.trim();
  $cli.value = '';
  if (!raw) return;

  print('> ' + raw, 'cmd');
  await runCmd(raw);
});

async function runCmd(raw) {
  const parts = raw.split(/\s+/);
  const cmd = parts[0].toLowerCase();

  // Numeric selection from last suggest results
  const numSel = parseInt(raw);
  if (lastSuggestions.length > 0 && !isNaN(numSel) && numSel >= 1 && numSel <= lastSuggestions.length && parts.length === 1) {
    const selected = lastSuggestions[numSel - 1];
    lastSuggestions = [];
    print(`> ${selected.cmd}`, 'cmd');
    await runCmd(selected.cmd);
    return;
  }

  // Command routing: check if command belongs to a different tab
  if (!GLOBAL_COMMANDS.has(cmd)) {
    const cmdTab = commandTab(cmd);
    if (cmdTab && cmdTab !== activeTab) {
      print(`'${cmd}' is a ${TAB_LABELS[cmdTab]} command \u2014 switch with Cmd+${TAB_KEYS[cmdTab]}`, 'warn');
      return;
    }
  }

  try {
    switch (cmd) {
      case 'help': {
        const helpId = 'help-block-' + activeTab;
        const old = document.getElementById(helpId);
        if (old) { old.remove(); break; }
        const helpDiv = document.createElement('div');
        helpDiv.id = helpId;
        let lines;
        if (activeTab === 'flow') {
          lines = [
            '',
            '  FLOW COMMANDS',
            '  auctions           list all auctions          Cmd+L',
            '  watch <id>         watch auction (symbol, #, or addr)',
            '  unwatch            stop watching',
            '  strategy <id> <min> <max> <amt> [exit] [stop-loss]  bid strategy',
            '  strategies         show active strategies',
            '  cancel <id>        cancel a strategy',
            '  arm <fdv> <amt>    schedule fixed bid for start',
            '  bid <fdv> <amt>    bid now on watched auction',
            '  info <id>          one-shot auction lookup',
            '',
            '  exit <id> [profile] [stop-loss]  start exit strategy',
            '                       profiles: conservative, moderate, aggressive',
            '                       custom: exit <id> 50@3x,50@5x',
            '                       stop-loss: exit <id> moderate 0.5',
            '  exits              list active exit strategies',
            '  exit-cancel <id>   cancel exit strategy',
            '  price <id>         check token price on Uniswap',
            '',
            '  launch <name> <symbol>  launch a new token',
            '',
            '  claim <id>         claim/exit a bid',
            '  claim-all          claim all claimable bids',
          ];
        } else if (activeTab === 'trade') {
          lines = [
            '',
            '  TRADE COMMANDS',
            '  trade dca <token> <amt> <interval> [budget] [sl%]',
            '  trade twap <token> <total> <duration> <chunks> [sl%]',
            '  trade mean-revert <token> <amt> <emaPeriod> <buyDip> <sellRip> [sl%]',
            '  trades             list active trading strategies',
            '  trade-cancel <id>  cancel trading strategy',
            '  trade-remove <id>  remove finished strategy from monitor',
            '  trade-pause <id>   pause trading strategy',
            '  trade-resume <id>  resume trading strategy',
            '  liquidate          cancel all strategies, sell all positions',
            '  suggest [token]    analyze token price, recommend strategy',
          ];
        } else {
          lines = [
            '',
            '  PORTFOLIO COMMANDS',
            '  wallet             show wallet info            Cmd+W',
            '  bids               show your bid history       Cmd+B',
          ];
        }
        // Append global commands + tab shortcuts
        lines.push('');
        lines.push('  GLOBAL');
        lines.push('  status             show agent state            Cmd+J');
        lines.push('  clear              clear output                Cmd+K');
        lines.push('  help               this message                Cmd+/');
        lines.push('');
        lines.push('  Cmd+1 Trade   Cmd+2 Flow   Cmd+3 Portfolio   Cmd+4 History');
        lines.push('');

        lines.forEach(l => {
          const d = document.createElement('div');
          d.className = 'line';
          d.textContent = l;
          helpDiv.appendChild(d);
        });
        const $out = $outputs[activeTab];
        $out.appendChild(helpDiv);
        $out.scrollTop = $out.scrollHeight;
        break;
      }

      case 'auctions':
      case 'ls': {
        const oldAuc = document.getElementById('auctions-block');
        if (oldAuc) { oldAuc.remove(); break; }
        const lRes = await fetch('/api/launches');
        const launches = await lRes.json();
        if (launches.error) throw new Error(launches.error);
        launchesCache = launches;
        const blockRes = await fetch('/api/block');
        const block = await blockRes.json();
        const cur = block.blockNumber;
        const aucDiv = document.createElement('div');
        aucDiv.id = 'auctions-block';
        function aucLine(text, cls) {
          const d = document.createElement('div');
          d.className = 'line' + (cls ? ' ' + cls : '');
          d.textContent = text;
          aucDiv.appendChild(d);
        }
        aucLine('');
        launches.forEach((l, i) => {
          const start = parseInt(l.startBlock);
          const end = parseInt(l.endBlock);
          let statusStr;
          if (cur < start) {
            const left = start - cur;
            statusStr = `starts in ${fmtTime(left * 2)}`;
          } else if (cur < end) {
            const left = end - cur;
            statusStr = `LIVE  ${fmtTime(left * 2)} left`;
          } else {
            statusStr = l.isGraduated ? 'graduated' : 'ended';
          }
          const line = `  ${String(i + 1).padStart(2)}  ${l.tokenSymbol.padEnd(10)} ${l.tokenName.slice(0, 25).padEnd(25)}  ${statusStr}`;
          const cls = cur < start ? 'warn' : cur < end ? 'ok' : 'dim';
          aucLine(line, cls);
        });
        aucLine('');
        aucLine('use: watch <symbol>, watch <#>, or watch <addr>  |  auctions to collapse', 'dim');
        aucLine('');
        const $out = $outputs[activeTab];
        $out.appendChild(aucDiv);
        $out.scrollTop = $out.scrollHeight;
        break;
      }

      case 'watch': {
        const input = parts[1];
        if (!input) { print('usage: watch <symbol | # | addr>', 'err'); break; }
        const addr = await resolveAuction(input);
        if (!addr) { print(`could not find auction: ${input}`, 'err'); break; }
        const match = launchesCache.find(l => l.auction === addr);
        const res = await fetch('/api/agent/watch', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ auctionAddress: addr }),
        });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        agentState = data;
        print(`watching ${match ? launchLabel(match) : shortAddr(addr)}`, 'ok');
        startPolling();
        break;
      }

      case 'unwatch':
      case 'stop': {
        const input = parts[1];
        if (input) {
          // Unwatch specific auction
          const addr = await resolveAuction(input);
          if (!addr) { print(`could not find auction: ${input}`, 'err'); break; }
          const res = await fetch('/api/agent/unwatch', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ auctionAddress: addr }),
          });
          agentState = await res.json();
          delete monitorData[addr];
          const match = launchesCache.find(l => l.auction === addr);
          print(`unwatched ${match ? launchLabel(match) : shortAddr(addr)}`, 'dim');
        } else {
          // Unwatch all
          const res = await fetch('/api/agent/unwatch', { method: 'POST' });
          agentState = await res.json();
          Object.keys(monitorData).forEach(k => delete monitorData[k]);
          print('stopped watching all', 'dim');
        }
        const hasActiveTrades = Array.isArray(tradingStrategiesCache) && tradingStrategiesCache.some(s => s.status === 'running' || s.status === 'paused');
        if (agentState.watching.length === 0 && !hasActiveTrades) stopPolling();
        renderAllMonitors();
        break;
      }

      case 'arm': {
        // arm <auction> <fdv> <amt> OR arm <fdv> <amt> (uses first watched)
        let auctionAddr, fdv, amt;
        if (parts.length >= 4) {
          auctionAddr = await resolveAuction(parts[1]);
          fdv = parts[2]; amt = parts[3];
        } else {
          fdv = parts[1]; amt = parts[2];
          auctionAddr = agentState.watching?.[0];
        }
        if (!fdv || !amt) { print('usage: arm [auction] <fdv> <amt>', 'err'); break; }
        if (!auctionAddr) { print('no auction specified or watched', 'err'); break; }
        print('arming agent...', 'dim');
        const res = await fetch('/api/bid/schedule', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            auctionAddress: auctionAddr,
            maxFdvUsd: Number(fdv),
            amount: Number(amt),
          }),
        });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        const match = launchesCache.find(l => l.auction === auctionAddr);
        print(`armed ${match ? match.tokenSymbol : shortAddr(auctionAddr)} \u2014 ${amt} USDC @ ${fmtUsd(Number(fdv))} FDV`, 'ok');
        break;
      }

      case 'disarm': {
        const disarmInput = parts[1];
        let disarmAddr = null;
        if (disarmInput) {
          disarmAddr = await resolveAuction(disarmInput);
          if (!disarmAddr) { print(`could not find auction: ${disarmInput}`, 'err'); break; }
        }
        const disarmRes = await fetch('/api/agent/disarm', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(disarmAddr ? { auctionAddress: disarmAddr } : {}),
        });
        agentState = await disarmRes.json();
        if (disarmAddr) {
          const match = launchesCache.find(l => l.auction === disarmAddr);
          print(`disarmed ${match ? match.tokenSymbol : shortAddr(disarmAddr)}`, 'ok');
        } else {
          print('disarmed all', 'ok');
        }
        renderAllMonitors();
        break;
      }

      case 'strategy': {
        // strategy <auction> <minFdv> <maxFdv> <amount> [exit-profile] [stop-loss]
        const id = parts[1];
        const minFdv = parts[2];
        const maxFdv = parts[3];
        const amt = parts[4];
        const exitProf = parts[5] || undefined;
        const stratStopLoss = parts[6] ? Number(parts[6]) : undefined;
        if (!id || !minFdv || !maxFdv || !amt) {
          print('usage: strategy <auction> <minFdv> <maxFdv> <amount> [exit-profile] [stop-loss]', 'err');
          print('  exit profiles: conservative, moderate, aggressive, or custom 50@3x,50@5x', 'dim');
          print('  stop-loss: e.g. 0.5 = sell all if drops below 0.5x entry', 'dim');
          break;
        }
        const addr = await resolveAuction(id);
        if (!addr) { print(`could not find auction: ${id}`, 'err'); break; }
        const match = launchesCache.find(l => l.auction === addr);
        print(`starting strategy on ${match ? match.tokenSymbol : shortAddr(addr)}...`, 'dim');
        print(`  FDV range: ${fmtUsd(Number(minFdv))} \u2192 ${fmtUsd(Number(maxFdv))}`, 'dim');
        print(`  Amount: ${amt} USDC`, 'dim');
        if (exitProf) print(`  Exit: ${exitProf}`, 'dim');
        if (stratStopLoss != null) print(`  Stop-loss: ${stratStopLoss}x`, 'dim');
        const stratBody = {
          auctionAddress: addr,
          minFdvUsd: Number(minFdv),
          maxFdvUsd: Number(maxFdv),
          amount: Number(amt),
        };
        if (exitProf) stratBody.exitProfile = exitProf;
        if (stratStopLoss != null) stratBody.stopLoss = stratStopLoss;
        const res = await fetch('/api/strategy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(stratBody),
        });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        let okMsg = `strategy active \u2014 agent will watch, then bid in final ~30s (max ${fmtUsd(Number(maxFdv))} FDV)`;
        if (exitProf) okMsg += ` | exit: ${exitProf}`;
        if (stratStopLoss != null) okMsg += ` | stop-loss: ${stratStopLoss}x`;
        print(okMsg, 'ok');
        if (!pollInterval) startPolling();
        break;
      }

      case 'strategies': {
        const res = await fetch('/api/strategies');
        const strats = await res.json();
        if (!Array.isArray(strats) || strats.length === 0) {
          print('no active strategies', 'dim');
          break;
        }
        strats.forEach(s => {
          const match = launchesCache.find(l => l.auction === s.auctionAddress);
          const name = match ? match.tokenSymbol : shortAddr(s.auctionAddress);
          print(`  ${name}  ${s.status}  fdv: ${fmtUsd(s.currentFdv)}  bids: ${s.bidsPlaced}  total: ${s.totalBids}`, (s.status === 'watching' || s.status === 'bidding') ? 'ok' : 'dim');
          // Show last 3 log entries
          s.log.slice(-3).forEach(l => {
            const ago = Math.round((Date.now() - l.time) / 1000);
            print(`    ${l.message} (${ago}s ago)`, l.type === 'error' ? 'err' : l.type === 'bid' ? 'ok' : 'dim');
          });
        });
        break;
      }

      case 'cancel': {
        const id = parts[1];
        if (!id) { print('usage: cancel <auction>', 'err'); break; }
        const addr = await resolveAuction(id);
        if (!addr) { print(`could not find auction: ${id}`, 'err'); break; }
        const res = await fetch(`/api/strategy/${addr}/cancel`, { method: 'POST' });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        const match = launchesCache.find(l => l.auction === addr);
        print(`cancelled strategy on ${match ? match.tokenSymbol : shortAddr(addr)}`, 'dim');
        break;
      }

      case 'exit': {
        // exit <auction> [profile] [stop-loss]
        const exitId = parts[1];
        const exitProfile = parts[2] || 'moderate';
        const exitStopLoss = parts[3] ? Number(parts[3]) : undefined;
        if (!exitId) {
          print('usage: exit <auction> [profile] [stop-loss]', 'err');
          print('  profiles: conservative, moderate, aggressive', 'dim');
          print('  custom:   exit <auction> 50@3x,50@5x', 'dim');
          print('  stop-loss: exit <auction> moderate 0.5', 'dim');
          break;
        }
        const exitAddr = await resolveAuction(exitId);
        if (!exitAddr) { print(`could not find auction: ${exitId}`, 'err'); break; }
        const exitMatch = launchesCache.find(l => l.auction === exitAddr);
        print(`starting exit strategy on ${exitMatch ? exitMatch.tokenSymbol : shortAddr(exitAddr)}...`, 'dim');
        print(`  profile: ${exitProfile}`, 'dim');
        if (exitStopLoss != null) print(`  stop-loss: ${exitStopLoss}x`, 'dim');
        const exitBody = {
          auctionAddress: exitAddr,
          profileOrCustom: exitProfile,
        };
        if (exitStopLoss != null) exitBody.stopLoss = exitStopLoss;
        const exitRes = await fetch('/api/exit-strategy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(exitBody),
        });
        const exitData = await exitRes.json();
        if (exitData.error) throw new Error(exitData.error);
        let exitOkMsg = `exit strategy active \u2014 entry FDV: ${fmtUsd(exitData.entryFdv)}`;
        if (exitStopLoss != null) exitOkMsg += ` | stop-loss: ${exitStopLoss}x`;
        print(exitOkMsg, 'ok');
        if (!pollInterval) startPolling();
        break;
      }

      case 'exits': {
        const exRes = await fetch('/api/exit-strategies');
        const exits = await exRes.json();
        if (!Array.isArray(exits) || exits.length === 0) {
          print('no active exit strategies', 'dim');
          break;
        }
        exits.forEach(e => {
          const match = launchesCache.find(l => l.auction === e.auctionAddress);
          const name = match ? match.tokenSymbol : shortAddr(e.auctionAddress);
          const multColor = e.status === 'stopped' ? 'err' : e.currentMultiple >= 2 ? 'ok' : e.currentMultiple >= 1 ? 'warn' : 'err';
          let exitLine = `  ${name}  ${e.profileName} ${e.status.toUpperCase()}  ${e.currentMultiple.toFixed(2)}x  realized: ${fmtUsd(e.totalUsdcRealized)}`;
          if (e.stopLossMultiple != null) exitLine += `  stop-loss: ${e.stopLossMultiple}x`;
          print(exitLine, multColor);
          // Show tranche status
          e.tranches.forEach(t => {
            const icon = t.status === 'executed' ? '\u2713' : t.status === 'skipped' ? '\u2717' : '\u25CB';
            let line = `    ${icon} ${t.pctToSell}% @ ${t.targetMultiple}x`;
            if (t.status === 'executed') line += ` \u2192 $${t.usdcReceived} USDC`;
            print(line, t.status === 'executed' ? 'ok' : 'dim');
          });
          // Last log
          if (e.log && e.log.length > 0) {
            const last = e.log[e.log.length - 1];
            const ago = Math.round((Date.now() - last.time) / 1000);
            print(`    ${last.message} (${ago}s ago)`, last.type === 'error' ? 'err' : last.type === 'sell' ? 'ok' : 'dim');
          }
        });
        break;
      }

      case 'exit-cancel': {
        const ecId = parts[1];
        if (!ecId) { print('usage: exit-cancel <auction>', 'err'); break; }
        const ecAddr = await resolveAuction(ecId);
        if (!ecAddr) { print(`could not find auction: ${ecId}`, 'err'); break; }
        const ecRes = await fetch(`/api/exit-strategy/${ecAddr}/cancel`, { method: 'POST' });
        const ecData = await ecRes.json();
        if (ecData.error) throw new Error(ecData.error);
        const ecMatch = launchesCache.find(l => l.auction === ecAddr);
        print(`cancelled exit strategy on ${ecMatch ? ecMatch.tokenSymbol : shortAddr(ecAddr)}`, 'dim');
        break;
      }

      case 'claim': {
        const claimId = parts[1];
        if (!claimId) { print('usage: claim <auction> or claim-all', 'err'); break; }
        const claimAddr = await resolveAuction(claimId);
        if (!claimAddr) { print(`could not find auction: ${claimId}`, 'err'); break; }
        print('claiming...', 'dim');
        const claimRes = await fetch('/api/claim', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ auctionAddress: claimAddr }),
        });
        const claimData = await claimRes.json();
        if (claimData.error) throw new Error(claimData.error);
        const claimMatch = launchesCache.find(l => l.auction === claimAddr);
        print(`claimed ${claimMatch ? claimMatch.tokenSymbol : shortAddr(claimAddr)} (${claimData.method})`, 'ok');
        if (claimData.note) print(`  ${claimData.note}`, 'dim');
        if (claimData.txHash) {
          printHtml(`  tx: <a href="https://basescan.org/tx/${claimData.txHash}" target="_blank" style="color:var(--cyan)">${claimData.txHash.slice(0, 10)}...${claimData.txHash.slice(-8)}</a>`);
        }
        break;
      }

      case 'claim-all': {
        print('claiming all...', 'dim');
        const caRes = await fetch('/api/claim-all', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        });
        const caData = await caRes.json();
        if (caData.error) throw new Error(caData.error);
        if (caData.status === 'nothing_to_claim') { print('no claimable bids found', 'dim'); break; }
        for (const c of caData.claimed || []) {
          const m = launchesCache.find(l => l.auction === c.auction);
          print(`  claimed ${m ? m.tokenSymbol : shortAddr(c.auction)} (${c.method})`, 'ok');
          if (c.txHash) {
            printHtml(`    tx: <a href="https://basescan.org/tx/${c.txHash}" target="_blank" style="color:var(--cyan)">${c.txHash.slice(0, 10)}...${c.txHash.slice(-8)}</a>`);
          }
        }
        for (const e of caData.errors || []) {
          const m = launchesCache.find(l => l.auction === e.auction);
          print(`  failed ${m ? m.tokenSymbol : shortAddr(e.auction)}: ${e.error.slice(0, 80)}`, 'err');
        }
        print(`done: ${(caData.claimed || []).length} claimed, ${(caData.errors || []).length} errors`, 'dim');
        break;
      }

      case 'launch': {
        if (parts.length < 3) { print('usage: launch <name> <SYMBOL> (last word is symbol)', 'err'); break; }
        const launchSymbol = parts[parts.length - 1];
        const launchName = parts.slice(1, -1).join(' ');
        print(`launching ${launchName} ($${launchSymbol})...`, 'dim');
        const launchRes = await fetch('/api/launch', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: launchName, symbol: launchSymbol }),
        });
        const launchData = await launchRes.json();
        if (launchData.error) throw new Error(launchData.error);
        const startIn = Math.round(
          (parseInt(launchData.auctionTiming.startBlock) - parseInt(launchData.auctionTiming.currentBlock)) * 2 / 60
        );
        print(`launched ${launchName} ($${launchSymbol})`, 'ok');
        print(`  token:   ${launchData.tokenAddress}`);
        print(`  auction: starts in ~${startIn}min (block ${launchData.auctionTiming.startBlock})`);
        if (launchData.txHash) {
          printHtml(`  tx: <a href="https://basescan.org/tx/${launchData.txHash}" target="_blank" style="color:var(--cyan)">${launchData.txHash.slice(0, 10)}...${launchData.txHash.slice(-8)}</a>`);
        }
        break;
      }

      case 'price': {
        const priceId = parts[1];
        if (!priceId) { print('usage: price <auction>', 'err'); break; }
        const priceAddr = await resolveAuction(priceId);
        if (!priceAddr) { print(`could not find auction: ${priceId}`, 'err'); break; }
        const priceLaunch = launchesCache.find(l => l.auction === priceAddr);
        if (!priceLaunch) { print('auction not found in launches', 'err'); break; }
        print('querying uniswap...', 'dim');
        const priceRes = await fetch(`/api/token/${priceLaunch.token}/price`);
        const priceData = await priceRes.json();
        if (priceData.error) throw new Error(priceData.error);
        print(`  ${priceLaunch.tokenSymbol} price: $${priceData.priceUsd.toFixed(6)}`, 'ok');
        break;
      }

      case 'bid': {
        // bid <auction> <fdv> <amt> OR bid <fdv> <amt> (uses first watched)
        let auctionAddr, fdv, amt;
        if (parts.length >= 4) {
          auctionAddr = await resolveAuction(parts[1]);
          fdv = parts[2]; amt = parts[3];
        } else {
          fdv = parts[1]; amt = parts[2];
          auctionAddr = agentState.watching?.[0];
        }
        if (!fdv || !amt) { print('usage: bid [auction] <fdv> <amt>', 'err'); break; }
        if (!auctionAddr) { print('no auction specified or watched', 'err'); break; }
        print('submitting bid...', 'dim');
        const res = await fetch('/api/bid', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            auctionAddress: auctionAddr,
            maxFdvUsd: Number(fdv),
            amount: Number(amt),
          }),
        });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        const match = launchesCache.find(l => l.auction === auctionAddr);
        print(`bid confirmed on ${match ? match.tokenSymbol : shortAddr(auctionAddr)}`, 'ok');
        if (data.txHashes) {
          data.txHashes.forEach((h, i) => {
            printHtml(`  tx ${i + 1}: <a href="https://basescan.org/tx/${h}" target="_blank" style="color:var(--cyan)">${h.slice(0, 10)}...${h.slice(-8)}</a>`);
          });
        }
        break;
      }

      case 'info': {
        const input = parts[1];
        if (!input) { print('usage: info <symbol | # | addr>', 'err'); break; }
        const addr = await resolveAuction(input);
        if (!addr) { print(`could not find auction: ${input}`, 'err'); break; }
        print('fetching...', 'dim');
        const [infoRes, bidsRes, blockRes] = await Promise.all([
          fetch(`/api/auction/${addr}`),
          fetch(`/api/auction/${addr}/bids`),
          fetch('/api/block'),
        ]);
        const [info, bids, block] = await Promise.all([
          infoRes.json(), bidsRes.json(), blockRes.json(),
        ]);
        if (info.error) throw new Error(info.error);
        printMonitorToOutput(info, bids, block);
        break;
      }

      case 'status': {
        const res = await fetch('/api/agent');
        agentState = await res.json();
        print(`status:   ${agentState.status}`);
        const w = agentState.watching || [];
        if (w.length === 0) {
          print('watching: none');
        } else {
          w.forEach(addr => {
            const match = launchesCache.find(l => l.auction === addr);
            print(`watching: ${match ? launchLabel(match) : shortAddr(addr)}`);
          });
        }
        (agentState.armedBids || []).forEach(ab => {
          const match = launchesCache.find(l => l.auction === ab.auctionAddress);
          print(`armed:    ${ab.amount} USDC @ ${fmtUsd(ab.maxFdvUsd)} FDV on ${match ? match.tokenSymbol : shortAddr(ab.auctionAddress)}`);
        });
        if (agentState.lastResult) {
          const r = agentState.lastResult;
          const ago = Math.round((Date.now() - r.timestamp) / 1000);
          print(`last:     ${r.message} (${ago}s ago)`, r.type === 'error' ? 'err' : 'ok');
        }
        break;
      }

      case 'bids': {
        const res = await fetch('/api/bids');
        const bids = await res.json();
        if (bids.error) throw new Error(bids.error);
        if (!Array.isArray(bids) || bids.length === 0) {
          print('no bids found', 'dim');
          break;
        }
        bids.forEach(b => {
          const addr = shortAddr(b.auctionAddress || b.auction || '\u2014');
          const amt = b.amount || b.amountRaw || '\u2014';
          const fdv = b.maxFdvUsd || b.maxFdv || '\u2014';
          const st = b.status || '\u2014';
          print(`  ${addr}  ${amt} USDC  FDV ${fdv}  ${st}`);
        });
        break;
      }

      case 'wallet': {
        const res = await fetch('/api/wallet');
        const w = await res.json();
        if (w.error) throw new Error(w.error);
        print(`  ${w.address}`);
        print(`  ETH: ${parseFloat(w.ethBalance).toFixed(6)}  USDC: ${parseFloat(w.usdcBalance).toFixed(2)}`);
        break;
      }

      case 'trade': {
        const subCmd = parts[1]?.toLowerCase();
        if (!subCmd) { print('usage: trade dca|twap|mean-revert <token> ...', 'err'); break; }

        const tokenInput = parts[2];
        if (!tokenInput) { print(`usage: trade ${subCmd} <token> ...`, 'err'); break; }

        // Resolve token address — server searches strategies, launches, and on-chain
        let tradeTokenAddress = tokenInput;
        if (!tokenInput.startsWith('0x')) {
          try {
            const resolveRes = await fetch(`/api/token/resolve/${encodeURIComponent(tokenInput)}`);
            if (!resolveRes.ok) { print(`could not resolve token: ${tokenInput}`, 'err'); break; }
            const resolved = await resolveRes.json();
            tradeTokenAddress = resolved.token;
          } catch { print(`could not resolve token: ${tokenInput}`, 'err'); break; }
        }

        if (subCmd === 'dca') {
          const amt = parts[3], interval = parts[4];
          if (!amt || !interval) { print('usage: trade dca <token> <amount> <interval> [budget] [stopLoss%]', 'err'); break; }
          const intMatch = interval.match(/^(\d+)(m|h|d)$/i);
          if (!intMatch) { print(`invalid interval: ${interval} (use 1h, 4h, 12h, 1d, 30m)`, 'err'); break; }
          const ival = parseInt(intMatch[1]);
          const iunit = intMatch[2].toLowerCase();
          const intervalMs = iunit === 'm' ? ival * 60000 : iunit === 'h' ? ival * 3600000 : ival * 86400000;
          const body = { type: 'dca', tokenAddress: tradeTokenAddress, params: { amountPerBuy: Number(amt), intervalMs }, riskLimits: {} };
          if (parts[5]) body.params.totalBudget = Number(parts[5]);
          if (parts[6]) body.riskLimits.stopLossPercent = Number(parts[6]);
          print(`starting DCA...`, 'dim');
          const res = await fetch('/api/trading-strategy', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
          const data = await res.json();
          if (data.error) throw new Error(data.error);
          print(`DCA started on ${data.tokenSymbol} \u2014 ${data.id}`, 'ok');
          print(`  $${amt} every ${interval}${parts[5] ? ' | budget: $' + parts[5] : ''}`, 'dim');
          if (!pollInterval) startPolling();
        } else if (subCmd === 'twap') {
          const total = parts[3], dur = parts[4], chunks = parts[5];
          if (!total || !dur || !chunks) { print('usage: trade twap <token> <total> <duration> <chunks> [stopLoss%]', 'err'); break; }
          const durMatch = dur.match(/^(\d+)(m|h|d)$/i);
          if (!durMatch) { print(`invalid duration: ${dur}`, 'err'); break; }
          const dval = parseInt(durMatch[1]);
          const dunit = durMatch[2].toLowerCase();
          const durationMs = dunit === 'm' ? dval * 60000 : dunit === 'h' ? dval * 3600000 : dval * 86400000;
          const body = { type: 'twap', tokenAddress: tradeTokenAddress, params: { totalAmount: Number(total), durationMs, chunks: Number(chunks) }, riskLimits: {} };
          if (parts[6]) body.riskLimits.stopLossPercent = Number(parts[6]);
          print(`starting TWAP...`, 'dim');
          const res = await fetch('/api/trading-strategy', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
          const data = await res.json();
          if (data.error) throw new Error(data.error);
          print(`TWAP started on ${data.tokenSymbol} \u2014 ${data.id}`, 'ok');
          print(`  $${total} over ${dur} in ${chunks} chunks ($${(Number(total) / Number(chunks)).toFixed(2)} each)`, 'dim');
          if (!pollInterval) startPolling();
        } else if (subCmd === 'mean-revert') {
          const amt = parts[3], emaPeriod = parts[4], buyDip = parts[5], sellRip = parts[6];
          if (!amt || !emaPeriod || !buyDip || !sellRip) { print('usage: trade mean-revert <token> <amt> <emaPeriod> <buyDip%> <sellRip%> [stopLoss%]', 'err'); break; }
          const body = { type: 'mean-reversion', tokenAddress: tradeTokenAddress, params: { amountPerTrade: Number(amt), emaPeriodMinutes: Number(emaPeriod), buyThresholdPct: Number(buyDip), sellThresholdPct: Number(sellRip) }, riskLimits: {} };
          if (parts[7]) body.riskLimits.stopLossPercent = Number(parts[7]);
          print(`starting mean-reversion...`, 'dim');
          const res = await fetch('/api/trading-strategy', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
          const data = await res.json();
          if (data.error) throw new Error(data.error);
          print(`Mean-Reversion started on ${data.tokenSymbol} \u2014 ${data.id}`, 'ok');
          print(`  $${amt}/trade, ${emaPeriod}min EMA, buy at -${buyDip}%, sell at +${sellRip}%`, 'dim');
          if (!pollInterval) startPolling();
        } else {
          print(`unknown trade sub-command: ${subCmd}`, 'err');
        }
        break;
      }

      case 'trades': {
        const res = await fetch('/api/trading-strategies');
        const strats = await res.json();
        if (!Array.isArray(strats) || strats.length === 0) {
          print('no active trading strategies', 'dim');
          break;
        }
        strats.forEach(s => {
          const lastPrice = s.priceHistory.length > 0 ? s.priceHistory[s.priceHistory.length - 1].price : 0;
          const posValue = s.position.tokenBalance * lastPrice;
          const pnlTotal = s.pnl.realized + s.pnl.unrealized;
          const pnlCls = pnlTotal >= 0 ? 'ok' : 'err';
          const pnlPct = s.position.totalInvested > 0 ? (pnlTotal / s.position.totalInvested * 100) : 0;
          print(`  ${s.type.toUpperCase()} ${s.tokenSymbol}  ${s.status}  id: ${s.id}`, s.status === 'running' ? 'ok' : 'dim');
          print(`    pos: ${fmtNum(s.position.tokenBalance)} ($${posValue.toFixed(2)}) | avg: $${s.position.avgEntryPrice.toFixed(6)} | pnl: ${pnlTotal >= 0 ? '+' : ''}${fmtUsd(pnlTotal)} (${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(1)}%)`, pnlCls);
          print(`    invested: ${fmtUsd(s.position.totalInvested)} | realized: ${fmtUsd(s.position.totalRealized)} | trades: ${s.trades.length}`, 'dim');
          if (s.log && s.log.length > 0) {
            const last = s.log[s.log.length - 1];
            const ago = Math.round((Date.now() - last.time) / 1000);
            print(`    ${last.message} (${ago}s ago)`, last.type === 'error' ? 'err' : last.type === 'trade' ? 'ok' : 'dim');
          }
        });
        break;
      }

      case 'trade-cancel': {
        const id = parts[1];
        if (!id) { print('usage: trade-cancel <id>', 'err'); break; }
        const res = await fetch(`/api/trading-strategy/${id}/cancel`, { method: 'POST' });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        print(`cancelled trading strategy ${id}`, 'dim');
        break;
      }

      case 'trade-remove': {
        const id = parts[1];
        if (!id) { print('usage: trade-remove <id>', 'err'); break; }
        const res2 = await fetch(`/api/trading-strategy/${id}`, { method: 'DELETE' });
        const data2 = await res2.json();
        if (data2.error) throw new Error(data2.error);
        print(`removed trading strategy ${id}`, 'dim');
        break;
      }

      case 'trade-pause': {
        const id = parts[1];
        if (!id) { print('usage: trade-pause <id>', 'err'); break; }
        const res = await fetch(`/api/trading-strategy/${id}/pause`, { method: 'POST' });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        print(`paused trading strategy ${id}`, 'dim');
        break;
      }

      case 'trade-resume': {
        const id = parts[1];
        if (!id) { print('usage: trade-resume <id>', 'err'); break; }
        const res = await fetch(`/api/trading-strategy/${id}/resume`, { method: 'POST' });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        print(`resumed trading strategy ${id}`, 'ok');
        break;
      }

      case 'liquidate': {
        const hasPositions = tradingStrategiesCache.some(s => s.status === 'running' || s.status === 'paused' || s.position.tokenBalance > 0);
        if (!hasPositions) { print('nothing to liquidate', 'dim'); break; }
        if (!confirm('Cancel all strategies and sell all positions to USDC?')) break;
        print('liquidating all positions...', 'warn');
        const res = await fetch('/api/trading/liquidate', { method: 'POST' });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        if (data.cancelled > 0) print(`cancelled ${data.cancelled} strategies`, 'dim');
        if (data.sold.length > 0) data.sold.forEach(s => print(`sold: ${s}`, 'ok'));
        if (data.errors.length > 0) data.errors.forEach(e => print(`error: ${e}`, 'err'));
        if (data.sold.length === 0 && data.errors.length === 0) print('no token positions to sell', 'dim');
        break;
      }

      case 'suggest': {
        const sugInput = parts.slice(1).join(' ');

        // ── suggest <token> — single-token analysis ──
        if (sugInput) {
          print('analyzing token...', 'dim');

          // Resolve token — server searches strategies, launches, and on-chain
          const cachedStrats = Array.isArray(tradingStrategiesCache) ? tradingStrategiesCache : [];
          let sugTokenAddr = null;
          let sugSymbol = null;

          try {
            const resolveRes = await fetch(`/api/token/resolve/${encodeURIComponent(sugInput)}`);
            if (resolveRes.ok) {
              const resolved = await resolveRes.json();
              sugTokenAddr = resolved.token;
              sugSymbol = resolved.symbol;
            }
          } catch {}

          // Fallback: raw address
          if (!sugTokenAddr && sugInput.startsWith('0x') && sugInput.length > 10) {
            sugTokenAddr = sugInput;
            sugSymbol = shortAddr(sugInput);
          }

          if (!sugTokenAddr) {
            print(`could not find token: ${sugInput}`, 'err');
            print('  use a token symbol, name, or 0x address', 'dim');
            break;
          }

          // Fetch price + wallet in parallel
          const [sugPriceRes, sugWalletRes] = await Promise.all([
            fetch(`/api/token/${sugTokenAddr}/price`),
            fetch('/api/wallet'),
          ]);
          const sugPriceData = await sugPriceRes.json();
          const sugWallet = await sugWalletRes.json();
          if (sugWallet.error) throw new Error(sugWallet.error);
          const usdcBal = parseFloat(sugWallet.usdcBalance);

          // Search tradingStrategiesCache for price history
          const stratWithHistory = cachedStrats.find(s =>
            s.tokenSymbol === sugSymbol || s.tokenAddress === sugTokenAddr
          );
          const history = stratWithHistory?.priceHistory || [];

          // Use API price, fall back to last history price
          const sugPrice = sugPriceData.priceUsd || (history.length > 0 ? history[history.length - 1].price : 0);

          if (!sugPrice) {
            print('');
            print(`  ${sugSymbol}`, '');
            print('  could not fetch price — token may not have liquidity yet', 'warn');
            print('');
            break;
          }

          print('');
          print(`  ${sugSymbol}  $${sugPrice.toFixed(sugPrice >= 1 ? 2 : 6)}`);
          print('');

          if (history.length > 30) {
            const analysis = analyzeToken(history);
            const span = history.length * 30; // seconds
            const spanH = (span / 3600).toFixed(1);

            print(`  ANALYSIS (${history.length} price points, ${spanH}h)`);
            const trendDir = analysis.trendPct > 3 ? 'bullish' : analysis.trendPct < -3 ? 'bearish' : 'ranging';
            const trendSign = analysis.trendPct >= 0 ? '+' : '';
            print(`  trend     ${trendSign}${analysis.trendPct.toFixed(1)}% (1h vs 4h avg — ${trendDir})`);
            const volLabel = analysis.hourlyVolPct > 8 ? 'high' : analysis.hourlyVolPct > 3 ? 'moderate' : 'low';
            print(`  vol       ${analysis.hourlyVolPct.toFixed(1)}%/hr (${volLabel})`);
            print(`  range     $${analysis.low.toFixed(analysis.low >= 1 ? 2 : 6)} — $${analysis.high.toFixed(analysis.high >= 1 ? 2 : 6)} (${analysis.rangePct.toFixed(1)}%)`);
            print(`  support   ~$${analysis.support.toFixed(analysis.support >= 1 ? 2 : 6)}   resistance  ~$${analysis.resistance.toFixed(analysis.resistance >= 1 ? 2 : 6)}`);
            print('');

            // Position sizing
            const baseSize = Math.min(usdcBal * 0.2, 500);
            const isHighVol = analysis.hourlyVolPct > 8;
            const isDowntrend = analysis.trendPct < -3;
            const isUptrend = analysis.trendPct > 3;
            const isRanging = !isUptrend && !isDowntrend;
            const sizeMultiplier = (isHighVol || isDowntrend) ? 0.5 : 1;
            const size = Math.max(5, Math.floor(baseSize * sizeMultiplier));

            // Stop-loss
            let stopLoss = 25;
            if (isHighVol) stopLoss += 5;
            if (isDowntrend) stopLoss -= 10;

            // Mean-reversion bands
            const bands = Math.max(2, Math.min(15, analysis.hourlyVolPct * 1.5));

            // EMA period
            const emaPeriod = isHighVol ? 30 : (analysis.hourlyVolPct > 3 ? 60 : 120);

            const suggestions = [];

            if (isUptrend && !isHighVol) {
              // Uptrend + low/moderate vol → DCA with larger amounts
              const budget = size * 6;
              const interval = '2h';
              const sl = Math.min(stopLoss + 10, 35);
              suggestions.push({
                label: `DCA into ${sugSymbol} — ride the uptrend`,
                detail: `$${size} every ${interval}, $${budget} budget, ${sl}% stop-loss`,
                cmd: `trade dca ${sugTokenAddr} ${size} ${interval} ${budget} ${sl}`,
              });
            }

            if (isUptrend && isHighVol) {
              // Uptrend + high vol → TWAP spread over 4h
              const total = size * 4;
              const chunks = Math.max(4, Math.min(12, Math.floor(total / 10)));
              const sl = Math.min(stopLoss, 30);
              suggestions.push({
                label: `TWAP buy ${sugSymbol} — spread the uptrend entry`,
                detail: `$${total} over 4h in ${chunks} chunks, ${sl}% stop-loss`,
                cmd: `trade twap ${sugTokenAddr} ${total} 4h ${chunks} ${sl}`,
              });
            }

            if (isRanging) {
              // Ranging → Mean-reversion
              const bandPct = bands.toFixed(1);
              suggestions.push({
                label: `Mean-reversion ${sugSymbol} — trade the ${analysis.rangePct.toFixed(0)}% range`,
                detail: `$${size}/trade, ${emaPeriod}min EMA, buy at -${bandPct}%, sell at +${bandPct}%, ${stopLoss}% stop`,
                cmd: `trade mean-revert ${sugTokenAddr} ${size} ${emaPeriod} ${bandPct} ${bandPct} ${stopLoss}`,
              });
            }

            if (isDowntrend) {
              // Downtrend → small DCA only
              const budget = size * 4;
              const sl = stopLoss;
              suggestions.push({
                label: `Small DCA into ${sugSymbol} — cautious accumulation`,
                detail: `$${size} every 4h, $${budget} budget, ${sl}% stop-loss`,
                cmd: `trade dca ${sugTokenAddr} ${size} 4h ${budget} ${sl}`,
              });
            }

            if (isHighVol) {
              // Very high vol → mean-reversion with wide bands
              const wideBands = Math.max(2, Math.min(15, analysis.hourlyVolPct * 1.5)).toFixed(1);
              const mrSize = Math.max(5, Math.floor(size * 0.7));
              suggestions.push({
                label: `Mean-reversion ${sugSymbol} — exploit high volatility`,
                detail: `$${mrSize}/trade, 30min EMA, buy at -${wideBands}%, sell at +${wideBands}%, ${stopLoss}% stop`,
                cmd: `trade mean-revert ${sugTokenAddr} ${mrSize} 30 ${wideBands} ${wideBands} ${stopLoss}`,
              });
            }

            // Always offer a DCA if not already suggested
            if (!isUptrend && !isDowntrend) {
              const dcaBudget = size * 6;
              suggestions.push({
                label: `DCA into ${sugSymbol} — steady accumulation`,
                detail: `$${size} every 2h, $${dcaBudget} budget, ${stopLoss}% stop-loss`,
                cmd: `trade dca ${sugTokenAddr} ${size} 2h ${dcaBudget} ${stopLoss}`,
              });
            }

            lastSuggestions = suggestions;
            print('  RECOMMENDATIONS', 'ok');
            print('');
            suggestions.forEach((s, i) => {
              print(`  ${i + 1}. ${s.label}`, 'ok');
              print(`     ${s.detail}`, 'dim');
              printHtml(`     <span style="color:var(--cyan);cursor:pointer" onclick="document.getElementById('cli').value='${s.cmd}';document.getElementById('cli').focus()">&gt; ${s.cmd}</span>`);
              print('');
            });
            print('  type a number to run, or click a command to load it', 'dim');
            print('');
          } else {
            // No history
            print('  no price history (start a strategy to begin tracking)', 'dim');
            print('');
            print('  RECOMMENDATION — conservative entry', 'ok');
            print('');
            const dcaSize = Math.max(5, Math.min(Math.floor(usdcBal * 0.1), 25));
            const dcaBudget = dcaSize * 8;
            const dcaCmd = `trade dca ${sugTokenAddr} ${dcaSize} 4h ${dcaBudget} 20`;
            lastSuggestions = [{ cmd: dcaCmd }];
            print(`  1. DCA into ${sugSymbol}`, 'ok');
            print(`     $${dcaSize} every 4h, $${dcaBudget} budget, 20% stop-loss`, 'dim');
            printHtml(`     <span style="color:var(--cyan);cursor:pointer" onclick="document.getElementById('cli').value='${dcaCmd}';document.getElementById('cli').focus()">&gt; ${dcaCmd}</span>`);
            print('');
            print('  type 1 to run, or click the command to load it', 'dim');
            print('');
          }
          break;
        }

        // ── suggest (no args) — scan all graduated tokens ──
        print('analyzing wallet and market...', 'dim');
        const [sugWalletRes, sugLaunchesRes, sugTradesRes] = await Promise.all([
          fetch('/api/wallet'),
          fetch('/api/launches'),
          fetch('/api/trading-strategies'),
        ]);
        const sugWallet = await sugWalletRes.json();
        if (sugWallet.error) throw new Error(sugWallet.error);
        const sugLaunches = await sugLaunchesRes.json();
        launchesCache = sugLaunches;
        let sugTrades = [];
        try { sugTrades = await sugTradesRes.json(); } catch {}
        if (!Array.isArray(sugTrades)) sugTrades = [];

        const usdcBalAll = parseFloat(sugWallet.usdcBalance);
        print('');
        print(`  wallet: ${fmtUsd(usdcBalAll)} USDC  ${parseFloat(sugWallet.ethBalance).toFixed(4)} ETH`);
        print('');

        // Find graduated tokens and fetch prices
        const graduated = sugLaunches.filter(l => l.isGraduated);
        if (graduated.length === 0) {
          print('  no graduated tokens available to trade', 'dim');
          break;
        }

        // Fetch prices in parallel
        const priceResults = await Promise.all(graduated.map(async l => {
          try {
            const r = await fetch(`/api/token/${l.token}/price`);
            const d = await r.json();
            return { ...l, price: d.priceUsd || 0, error: d.error };
          } catch { return { ...l, price: 0, error: true }; }
        }));
        const tradeable = priceResults.filter(t => t.price > 0 && !t.error);

        if (tradeable.length === 0) {
          print('  no tokens with active liquidity found', 'dim');
          break;
        }

        // Show available tokens
        print('  tradeable tokens:', 'dim');
        tradeable.forEach(t => {
          print(`    ${t.tokenSymbol.padEnd(10)} $${t.price.toFixed(6)}`);
        });
        print('');

        // Check which tokens already have active strategies
        const activeSymbols = new Set(sugTrades.filter(s => s.status === 'running' || s.status === 'paused').map(s => s.tokenSymbol));

        if (usdcBalAll < 1) {
          print('  insufficient USDC for trading', 'warn');
          break;
        }

        // Generate suggestions
        const suggestions = [];
        const maxPerStrategy = Math.min(usdcBalAll * 0.25, 500); // max 25% of wallet or $500
        const minTrade = 5;

        tradeable.forEach(t => {
          const sym = t.tokenSymbol;
          const hasPosition = activeSymbols.has(sym);

          if (!hasPosition && usdcBalAll >= 20) {
            // New token: suggest DCA for gradual entry
            const budget = Math.min(maxPerStrategy, Math.floor(usdcBalAll * 0.2));
            const perBuy = Math.max(minTrade, Math.floor(budget / 8));
            suggestions.push({
              type: 'dca',
              label: `DCA into ${sym}`,
              reason: 'gradual entry, reduces timing risk',
              cmd: `trade dca ${sym} ${perBuy} 4h ${budget} 30`,
              detail: `$${perBuy} every 4h, $${budget} budget, 30% stop-loss`,
            });
          }

          if (!hasPosition && usdcBalAll >= 50) {
            // TWAP for larger one-time allocation
            const total = Math.min(maxPerStrategy, Math.floor(usdcBalAll * 0.15));
            const chunks = Math.max(4, Math.min(12, Math.floor(total / 10)));
            suggestions.push({
              type: 'twap',
              label: `TWAP buy ${sym}`,
              reason: 'spread a buy over time to reduce slippage',
              cmd: `trade twap ${sym} ${total} 2h ${chunks} 25`,
              detail: `$${total} over 2h in ${chunks} chunks, 25% stop-loss`,
            });
          }

          // Mean-reversion works with or without existing position
          if (usdcBalAll >= 20) {
            const perTrade = Math.max(minTrade, Math.floor(maxPerStrategy / 10));
            suggestions.push({
              type: 'mean-revert',
              label: `Mean-revert ${sym}`,
              reason: hasPosition ? 'already holding, trade the range' : 'buy dips, sell rips around EMA',
              cmd: `trade mean-revert ${sym} ${perTrade} 60 5 5 30`,
              detail: `$${perTrade}/trade, 60min EMA, buy at -5%, sell at +5%, 30% stop-loss`,
            });
          }
        });

        if (suggestions.length === 0) {
          print('  no suggestions — balance too low or all tokens covered', 'dim');
          break;
        }

        // Show top suggestions (limit to avoid wall of text)
        const shown = suggestions.slice(0, 6);
        lastSuggestions = shown;
        print('  SUGGESTIONS', 'ok');
        print('');
        shown.forEach((s, i) => {
          print(`  ${i + 1}. ${s.label}`, 'ok');
          print(`     ${s.reason}`, 'dim');
          print(`     ${s.detail}`, 'dim');
          printHtml(`     <span style="color:var(--cyan);cursor:pointer" onclick="document.getElementById('cli').value='${s.cmd}';document.getElementById('cli').focus()">&gt; ${s.cmd}</span>`);
          print('');
        });
        print('  type a number to run, or click a command to load it', 'dim');
        print('');
        break;
      }

      case 'clear':
        $outputs[activeTab].innerHTML = '';
        break;

      default:
        print(`unknown command: ${cmd} \u2014 type help`, 'err');
    }
  } catch (e) {
    print(e.message, 'err');
  }
}

// ─── Theme ───
function toggleTheme() {
  const html = document.documentElement;
  const isLight = html.getAttribute('data-theme') === 'light';
  if (isLight) {
    html.removeAttribute('data-theme');
    localStorage.setItem('theme', 'dark');
    document.getElementById('theme-toggle').textContent = '\u263E';
  } else {
    html.setAttribute('data-theme', 'light');
    localStorage.setItem('theme', 'light');
    document.getElementById('theme-toggle').textContent = '\u2600';
  }
}

(function initTheme() {
  const saved = localStorage.getItem('theme');
  if (saved === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    document.getElementById('theme-toggle').textContent = '\u2600';
  } else {
    document.getElementById('theme-toggle').textContent = '\u263E';
  }
})();

// ─── Readiness alerts ───
const seenAlerts = new Set(); // "addr:stage" keys already shown this session
let notifPermissionAsked = false;

function playBeep() {
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 880;
    gain.gain.value = 0.3;
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.3);
  } catch {}
}

function checkReadinessAlerts() {
  const alerts = agentState.readinessAlerts || [];
  const container = document.getElementById('toast-container');

  alerts.forEach(alert => {
    const key = alert.auctionAddress + ':' + alert.stage;
    if (seenAlerts.has(key)) return;
    seenAlerts.add(key);

    const { checks } = alert;
    const allGood = checks.usdc.ok && checks.eth.ok && checks.config.ok;
    const timeLabel = alert.stage === '15min' ? '~15min' : alert.stage === '5min' ? '~5min' : '~1min';

    // Find token name
    const match = launchesCache.find(l => l.auction === alert.auctionAddress);
    const tokenLabel = match ? match.tokenSymbol : shortAddr(alert.auctionAddress);

    // Build toast
    const toast = document.createElement('div');
    toast.className = 'toast' + (allGood ? ' all-good' : '');
    toast.id = 'toast-' + key.replace(/[^a-zA-Z0-9]/g, '-');

    const usdcCls = checks.usdc.ok ? 'check-ok' : 'check-fail';
    const ethCls = checks.eth.ok ? 'check-ok' : 'check-fail';
    const configCls = checks.config.ok ? 'check-ok' : 'check-fail';

    toast.innerHTML = `
      <button class="toast-close" onclick="dismissToast('${alert.auctionAddress}','${alert.stage}')">\u00D7</button>
      <div class="toast-title">${tokenLabel} \u2014 Auction in ${timeLabel}</div>
      <div class="${usdcCls}">${checks.usdc.ok ? '\u2713' : '\u2717'} USDC: $${checks.usdc.balance.toFixed(2)} (need $${checks.usdc.needed.toFixed(2)})</div>
      <div class="${ethCls}">${checks.eth.ok ? '\u2713' : '\u2717'} ETH: ${checks.eth.balance.toFixed(4)} (gas)</div>
      <div class="${configCls}">${checks.config.ok ? '\u2713' : '\u2717'} ${checks.config.description}</div>
      <div style="margin-top:4px;font-weight:bold;color:${allGood ? 'var(--green)' : 'var(--yellow)'}">${allGood ? 'Ready to go.' : 'Action needed.'}</div>
    `;
    container.appendChild(toast);

    // Audio beep
    playBeep();

    // Browser notification
    if (Notification.permission === 'granted') {
      new Notification(`${tokenLabel} \u2014 Auction in ${timeLabel}`, {
        body: allGood ? 'Ready to go.' : 'Action needed \u2014 check wallet.',
      });
    } else if (Notification.permission !== 'denied' && !notifPermissionAsked) {
      notifPermissionAsked = true;
      Notification.requestPermission();
    }

    // Auto-dismiss passing alerts after 15s
    if (allGood) {
      setTimeout(() => dismissToast(alert.auctionAddress, alert.stage), 15000);
    }
  });
}

function dismissToast(auctionAddress, stage) {
  const key = auctionAddress + ':' + stage;
  const id = 'toast-' + key.replace(/[^a-zA-Z0-9]/g, '-');
  const el = document.getElementById(id);
  if (el) el.remove();
  fetch('/api/readiness/dismiss', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ auctionAddress, stage }),
  }).catch(() => {});
}

// ─── Boot ───
async function boot() {
  // Load wallet into topbar
  try {
    const res = await fetch('/api/wallet');
    const w = await res.json();
    if (!w.error) {
      document.getElementById('wallet').innerHTML =
        `<span>${shortAddr(w.address)}</span> ETH: <span>${parseFloat(w.ethBalance).toFixed(4)}</span> USDC: <span>${parseFloat(w.usdcBalance).toFixed(2)}</span>`;
    }
  } catch {}
  // Fetch ETH price for gas fee display
  try {
    const ep = await fetch('/api/token/0x4200000000000000000000000000000000000006/price');
    const epd = await ep.json();
    if (epd.price) ethPriceUsd = epd.price;
  } catch {}

  // Load launches + agent state in parallel
  try {
    const [agentRes, launchesRes] = await Promise.all([
      fetch('/api/agent'),
      fetch('/api/launches'),
    ]);
    agentState = await agentRes.json();
    launchesCache = await launchesRes.json();
  } catch {}

  // Check for active trading strategies
  try {
    const tradingRes = await fetch('/api/trading-strategies');
    tradingStrategiesCache = await tradingRes.json();
  } catch { tradingStrategiesCache = []; }
  tradingStrategiesCache.forEach(s => { if (!collapsedStrategies.has('_seen_' + s.id)) { collapsedStrategies.add(s.id); collapsedStrategies.add('_seen_' + s.id); } });
  const runningTrades = Array.isArray(tradingStrategiesCache) ? tradingStrategiesCache.filter(s => s.status === 'running' || s.status === 'paused') : [];

  const watching = agentState.watching || [];

  // Auto-select tab based on activity
  if (watching.length > 0 && runningTrades.length === 0) {
    switchTab('flow');
  } else {
    switchTab('trade');
  }

  printTo('flow', 'terminal.flow.bid', 'dim');
  printTo('flow', '');

  if (watching.length > 0 || runningTrades.length > 0) {
    watching.forEach(addr => {
      const match = launchesCache.find(l => l.auction === addr);
      printTo('flow', `resuming watch on ${match ? launchLabel(match) : shortAddr(addr)}`, 'ok');
    });
    if (agentState.status === 'armed' && agentState.armedBids?.length) {
      agentState.armedBids.forEach(ab => {
        const m = launchesCache.find(l => l.auction === ab.auctionAddress);
        printTo('flow', `agent armed: ${m ? m.tokenSymbol : shortAddr(ab.auctionAddress)} \u2014 ${ab.amount} USDC @ ${fmtUsd(ab.maxFdvUsd)} FDV`, 'warn');
      });
    }
    runningTrades.forEach(s => {
      printTo('trade', `resuming ${s.type} strategy on ${s.tokenSymbol} (${s.id})`, 'ok');
    });
    startPolling();
  } else {
    // Preload auctions into flow tab without switching
    try {
      const lRes = await fetch('/api/launches');
      const launches = await lRes.json();
      launchesCache = launches;
    } catch {}
  }
}

// Auth check → boot
checkAuth().then(ok => { if (ok) boot(); });

// Keep focus on CLI input — click anywhere to refocus (skip if login overlay is visible)
document.addEventListener('click', () => {
  if (!document.getElementById('login-overlay').classList.contains('hidden')) return;
  $cli.focus();
});
document.addEventListener('keydown', (e) => {
  if (!document.getElementById('login-overlay').classList.contains('hidden')) return;
  if (document.activeElement !== $cli) {
    $cli.focus();
  }
});
</script>
</body>
</html>
